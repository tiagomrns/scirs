name: Memory Leak Detection

on:
  push:
    branches: [ master, main, develop ]
  pull_request:
    branches: [ master, main ]
  schedule:
    # Run daily memory leak detection
    - cron: '0 4 * * *'

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  memory-leak-detection:
    name: Memory Leak Detection
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
        rust: [stable]
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            valgrind: true
          - os: macos-latest
            target: x86_64-apple-darwin
            valgrind: false

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
        targets: ${{ matrix.target }}

    - name: Install memory analysis tools (Ubuntu)
      if: matrix.os == 'ubuntu-latest'
      run: |
        sudo apt-get update
        sudo apt-get install -y valgrind massif-visualizer heaptrack
        # Install AddressSanitizer and LeakSanitizer
        sudo apt-get install -y libc6-dbg

    - name: Install memory analysis tools (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        # Install memory analysis tools for macOS
        brew install leaks malloc_history

    - name: Cache Cargo dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          target/
        key: ${{ runner.os }}-cargo-memory-${{ hashFiles('**/Cargo.lock') }}

    - name: Build with debug info and sanitizers
      run: |
        # Build with address sanitizer for leak detection
        export RUSTFLAGS="-Z sanitizer=address"
        cargo +nightly build --target ${{ matrix.target }} \
          --features "memory-profiling debug-allocations"

    - name: Run memory leak detection tests
      run: |
        mkdir -p memory_results
        
        # Run built-in memory leak detection
        cargo run --target ${{ matrix.target }} \
          --example memory_leak_detector_demo \
          -- --output memory_results/leak_detection.json \
             --enable-tracking \
             --sensitivity 0.9

    - name: Run Valgrind memory analysis (Ubuntu only)
      if: matrix.valgrind == true
      run: |
        # Run Valgrind memcheck for leak detection
        valgrind --tool=memcheck \
          --leak-check=full \
          --show-leak-kinds=all \
          --track-origins=yes \
          --xml=yes \
          --xml-file=memory_results/valgrind_memcheck.xml \
          cargo run --target ${{ matrix.target }} \
          --example memory_efficient_training
        
        # Run Valgrind massif for heap profiling
        valgrind --tool=massif \
          --massif-out-file=memory_results/massif.out \
          --time-unit=B \
          cargo run --target ${{ matrix.target }} \
          --example comprehensive_benchmarking_example
        
        # Convert massif output to text
        ms_print memory_results/massif.out > memory_results/massif_report.txt

    - name: Run HeapTrack analysis (Ubuntu only)
      if: matrix.os == 'ubuntu-latest'
      run: |
        # Run HeapTrack for advanced heap analysis
        heaptrack --output memory_results/heaptrack.out \
          cargo run --target ${{ matrix.target }} \
          --example advanced_optimizers
        
        # Analyze HeapTrack results
        heaptrack_print memory_results/heaptrack.out > memory_results/heaptrack_analysis.txt

    - name: Run macOS leak detection
      if: matrix.os == 'macos-latest'
      run: |
        # Run macOS leaks tool
        leaks --atExit -- \
          cargo run --target ${{ matrix.target }} \
          --example memory_efficient_training \
          > memory_results/macos_leaks.txt 2>&1 || true

    - name: Run comprehensive memory profiling
      run: |
        # Run our comprehensive memory profiler
        cargo run --target ${{ matrix.target }} \
          --example comprehensive_memory_profiler \
          -- --output memory_results/memory_profile.json \
             --duration 300 \
             --sampling-rate 1000

    - name: Analyze memory patterns
      run: |
        # Run memory pattern analysis
        cargo run --target ${{ matrix.target }} \
          --bin memory_pattern_analyzer \
          -- --input memory_results/ \
             --output memory_results/pattern_analysis.json

    - name: Generate memory leak report
      run: |
        # Generate comprehensive memory leak report
        cargo run --target ${{ matrix.target }} \
          --bin memory_leak_reporter \
          -- --input memory_results/ \
             --output memory_results/leak_report.json \
             --format github-actions

    - name: Upload memory analysis artifacts
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: memory-analysis-${{ matrix.os }}
        path: |
          memory_results/
        retention-days: 30

    - name: Comment memory analysis on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          try {
            const reportPath = 'memory_results/leak_report.json';
            if (fs.existsSync(reportPath)) {
              const report = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
              
              let comment = '## 🧠 Memory Leak Detection Results\n\n';
              comment += `**Platform**: ${{ matrix.os }}\n`;
              
              if (report.leaks_detected && report.leaks_detected.length > 0) {
                comment += '### ⚠️ Memory Leaks Detected\n\n';
                report.leaks_detected.forEach((leak, index) => {
                  comment += `**Leak ${index + 1}**:\n`;
                  comment += `- **Severity**: ${leak.severity}\n`;
                  comment += `- **Leaked Memory**: ${leak.leaked_memory_bytes} bytes\n`;
                  comment += `- **Confidence**: ${leak.confidence}\n`;
                  comment += `- **Sources**: ${leak.leak_sources.length}\n\n`;
                });
                comment += '⚠️ **Action Required**: Please review and fix the detected memory leaks.\n';
              } else {
                comment += '### ✅ No Memory Leaks Detected\n\nMemory analysis completed successfully!\n';
              }
              
              if (report.recommendations && report.recommendations.length > 0) {
                comment += '\n### 💡 Optimization Recommendations\n\n';
                report.recommendations.slice(0, 5).forEach(rec => {
                  comment += `- **${rec.recommendation_type}**: ${rec.description}\n`;
                });
              }
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
          } catch (error) {
            console.log('Could not post memory analysis results:', error);
          }

    - name: Fail job on critical memory leaks
      if: always()
      run: |
        # Check for critical memory leaks
        if [ -f "memory_results/leak_report.json" ]; then
          critical_leaks=$(cat memory_results/leak_report.json | jq '[.leaks_detected[]? | select(.severity > 0.8)] | length')
          if [ "$critical_leaks" -gt 0 ]; then
            echo "::error::Critical memory leaks detected! $critical_leaks critical leak(s) found."
            echo "::error::Please fix these memory leaks before merging."
            exit 1
          fi
          
          total_leaked=$(cat memory_results/leak_report.json | jq '[.leaks_detected[]? | .leaked_memory_bytes] | add // 0')
          if [ "$total_leaked" -gt 10485760 ]; then  # 10MB threshold
            echo "::error::Excessive memory leakage detected: $total_leaked bytes leaked."
            echo "::error::Please optimize memory usage before merging."
            exit 1
          fi
        fi

  memory-stress-testing:
    name: Memory Stress Testing
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable

    - name: Install stress testing tools
      run: |
        sudo apt-get update
        sudo apt-get install -y stress-ng htop

    - name: Run memory stress tests
      run: |
        mkdir -p stress_results
        
        # Run memory stress tests with various optimizers
        cargo run --release --example memory_stress_tester \
          -- --output stress_results/stress_test.json \
             --duration 600 \
             --max-memory 2GB \
             --concurrent-optimizers 8

    - name: Analyze stress test results
      run: |
        # Analyze stress test performance
        cargo run --release --bin stress_test_analyzer \
          -- --input stress_results/stress_test.json \
             --output stress_results/stress_analysis.json

    - name: Upload stress test results
      uses: actions/upload-artifact@v3
      with:
        name: memory-stress-results
        path: stress_results/

  long-running-memory-test:
    name: Long-Running Memory Test
    runs-on: ubuntu-latest
    timeout-minutes: 720  # 12 hours
    if: github.event_name == 'schedule'
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable

    - name: Run long-running memory test
      run: |
        mkdir -p longrun_results
        
        # Run 12-hour memory stability test
        timeout 12h cargo run --release --example long_running_memory_test \
          -- --output longrun_results/longrun_memory.json \
             --duration 43200 \
             --sampling-interval 60 \
          || true

    - name: Analyze long-running results
      if: always()
      run: |
        # Analyze long-running test results
        if [ -f "longrun_results/longrun_memory.json" ]; then
          cargo run --release --bin longrun_analyzer \
            -- --input longrun_results/longrun_memory.json \
               --output longrun_results/longrun_analysis.json
        fi

    - name: Upload long-running test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: longrun-memory-results
        path: longrun_results/