//! Comprehensive documentation and usage examples for scirs2-ndimage
//!
//! This example serves as a complete guide to using scirs2-ndimage, covering:
//! - All major API categories with detailed examples
//! - Best practices for performance and memory efficiency
//! - Advanced features and optimization techniques
//! - Error handling and edge cases
//! - Integration with other scirs2 modules

use ndarray::{Array2, Array3, ArrayView2, Axis};
use scirs2_ndimage::{
    backend::*, domain_specific::*, error::NdimageResult, features::*, filters::*,
    interpolation::*, measurements::*, morphology::*, segmentation::*, streaming::*,
    visualization::*,
};

#[allow(dead_code)]
fn main() -> NdimageResult<()> {
    println!("=== Comprehensive scirs2-ndimage Documentation & Examples ===\n");

    // Create various test images for different examples
    let testimage_2d = create_testimage_2d(128, 128);
    let testimage_3d = create_testimage_3d(64, 64, 32);
    let noisyimage = add_noise(&testimage_2d, 0.1);
    let edgeimage = create_edge_testimage(64, 64);

    // 1. Filtering Operations
    println!("--- 1. FILTERING OPERATIONS ---\n");
    demonstrate_filtering(&testimage_2d, &noisyimage)?;

    // 2. Feature Detection
    println!("\n--- 2. FEATURE DETECTION ---\n");
    demonstrate_feature_detection(&edgeimage)?;

    // 3. Morphological Operations
    println!("\n--- 3. MORPHOLOGICAL OPERATIONS ---\n");
    demonstrate_morphology(&testimage_2d)?;

    // 4. Interpolation and Transformations
    println!("\n--- 4. INTERPOLATION & TRANSFORMATIONS ---\n");
    demonstrate_interpolation(&testimage_2d)?;

    // 5. Measurements and Analysis
    println!("\n--- 5. MEASUREMENTS & ANALYSIS ---\n");
    demonstrate_measurements(&testimage_2d)?;

    // 6. Segmentation
    println!("\n--- 6. SEGMENTATION ---\n");
    demonstrate_segmentation(&testimage_2d)?;

    // 7. Domain-Specific Functions
    println!("\n--- 7. DOMAIN-SPECIFIC FUNCTIONS ---\n");
    demonstrate_domain_specific(&testimage_2d)?;

    // 8. Advanced SIMD Extensions
    #[cfg(feature = "simd")]
    {
        println!("\n--- 8. ADVANCED SIMD EXTENSIONS ---\n");
        demonstrate_advanced_simd(&testimage_2d)?;
    }

    // 9. Backend and Performance
    println!("\n--- 9. BACKEND & PERFORMANCE OPTIMIZATION ---\n");
    demonstrate_backends(&testimage_2d)?;

    // 10. Streaming for Large Data
    println!("\n--- 10. STREAMING FOR LARGE DATASETS ---\n");
    demonstrate_streaming()?;

    // 11. Memory Management
    println!("\n--- 11. MEMORY MANAGEMENT ---\n");
    demonstrate_memory_management(&testimage_2d)?;

    // 12. Visualization
    println!("\n--- 12. VISUALIZATION ---\n");
    demonstrate_visualization(&testimage_2d)?;

    // 13. Best Practices and Tips
    println!("\n--- 13. BEST PRACTICES & OPTIMIZATION TIPS ---\n");
    demonstrate_best_practices()?;

    println!("\n=== Documentation Examples Complete ===");
    println!("For more details, see the API documentation and individual module examples.");

    Ok(())
}

#[allow(dead_code)]
fn create_testimage_2d(height: usize, width: usize) -> Array2<f64> {
    Array2::from_shape_fn((height, width), |(i, j)| {
        let x = i as f64 / height as f64;
        let y = j as f64 / width as f64;

        // Create multiple patterns
        let pattern1 = (x * std::f64::consts::PI * 4.0).sin();
        let pattern2 = (y * std::f64::consts::PI * 6.0).cos();
        let radial = ((x - 0.5).powi(2) + (y - 0.5).powi(2)).sqrt();

        0.5 + 0.3 * pattern1 * pattern2 + 0.2 * (1.0 - radial).max(0.0)
    })
}

#[allow(dead_code)]
fn create_testimage_3d(height: usize, width: usize, depth: usize) -> Array3<f64> {
    Array3::from_shape_fn((height, width, depth), |(i, j, k)| {
        let x = i as f64 / height as f64;
        let y = j as f64 / width as f64;
        let z = k as f64 / depth as f64;

        ((x * std::f64::consts::PI).sin()
            + (y * std::f64::consts::PI).cos()
            + (z * std::f64::consts::PI).sin())
            / 3.0
    })
}

#[allow(dead_code)]
fn add_noise(image: &Array2<f64>, noiselevel: f64) -> Array2<f64> {
    image
        + &Array2::from_shape_fn(image.dim(), |(i, j)| {
            let noise = if (i * 7 + j * 11) % 13 == 0 {
                noiselevel
            } else {
                -noiselevel
            };
            if (i + j) % 3 == 0 {
                noise
            } else {
                0.0
            }
        })
}

#[allow(dead_code)]
fn create_edge_testimage(height: usize, width: usize) -> Array2<f64> {
    Array2::from_shape_fn((height, width), |(i, j)| {
        // Create step edges and lines
        if i > height / 2 && i < height / 2 + 5 {
            1.0
        } else if j > width / 2 && j < width / 2 + 5 {
            1.0
        } else if ((i as f64 - height as f64 / 2.0).powi(2)
            + (j as f64 - width as f64 / 2.0).powi(2))
        .sqrt()
            < 15.0
        {
            0.8
        } else {
            0.0
        }
    })
}

#[allow(dead_code)]
fn demonstrate_filtering(image: &Array2<f64>, noisyimage: &Array2<f64>) -> NdimageResult<()> {
    println!("üîç Filtering Operations");

    // 1. Basic filters
    println!("  ‚Ä¢ Gaussian filtering (noise reduction):");
    let gaussian = gaussian_filter(&image, 2.0, None, None)?;
    println!(
        "    Input: {}x{}, Output: {}x{}",
        image.nrows(),
        image.ncols(),
        gaussian.nrows(),
        gaussian.ncols()
    );

    // 2. Edge detection filters
    println!("  ‚Ä¢ Edge detection filters:");
    let sobel_result = sobel(&image, 0, None)?;
    let laplace_result = laplace(&image, None, None)?;
    println!("    Sobel edges detected, Laplacian computed");

    // 3. Rank filters
    println!("  ‚Ä¢ Rank filters (noise removal):");
    let median = median_filter(&noisyimage, &[3, 3], None)?;
    let max_filter = maximum_filter(&image, &[3, 3], None, None)?;
    println!("    Median filter applied, maximum filter computed");

    // 4. Advanced filters
    println!("  ‚Ä¢ Advanced filters:");
    let bilateral = bilateral_filter(image.view(), 2.0, 0.1, None)?;
    println!("    Bilateral filter (edge-preserving smoothing) applied");

    // 5. Generic filters with custom functions
    println!("  ‚Ä¢ Generic filters with custom functions:");
    let custom_filter = generic_filter(
        &image.view(),
        None, // use default 3x3 footprint
        |neighborhood: &[f64]| {
            neighborhood.iter().fold(0.0, |sum, &x| sum + x) / neighborhood.len() as f64
        }, // use mean as the filter function
        None, // mode
        None, // cval
        None, // origin
        None, // axes
    )?;
    println!("    Custom variance filter applied");

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_feature_detection(image: &Array2<f64>) -> NdimageResult<()> {
    println!("üéØ Feature Detection");

    // 1. Edge detection
    println!("  ‚Ä¢ Edge detection methods:");
    let canny_edges = canny(image.view(), 1.0, 0.1, 0.3, None)?;
    let sobel_edges = sobel_edges(image.view(), None)?;
    println!("    Canny and Sobel edge detection completed");

    // 2. Corner detection
    println!("  ‚Ä¢ Corner detection:");
    let harris_corners = harris_corners(image.view(), 0.04, 3, 0.01, None)?;
    let fast_corners = fast_corners(image.view(), 9, 0.15, None)?;
    println!("    Harris and FAST corner detection completed");

    #[cfg(feature = "simd")]
    {
        // 3. Machine learning-based detection
        println!("  ‚Ä¢ ML-based feature detection:");
        let ml_config = MLDetectorConfig::default();
        let learned_detector = LearnedEdgeDetector::new(ml_config)?;
        let ml_edges = learned_detector.detect_edges(image.view())?;
        println!("    ML-based edge detection completed");
    }

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_morphology(image: &Array2<f64>) -> NdimageResult<()> {
    println!("üî¨ Morphological Operations");

    // Create binary image for morphology
    let binary_image = image.mapv(|x| if x > 0.5 { 1u8 } else { 0u8 });

    // 1. Basic binary morphology
    println!("  ‚Ä¢ Basic binary morphology:");
    let structure = generate_binary_structure(2, 1)?;
    let eroded = binary_erosion(
        &binary_image.view(),
        Some(&structure.view()),
        None,
        None,
        None,
        None,
    )?;
    let dilated = binary_dilation(
        &binary_image.view(),
        Some(&structure.view()),
        None,
        None,
        None,
        None,
    )?;
    println!("    Binary erosion and dilation completed");

    // 2. Compound operations
    println!("  ‚Ä¢ Compound morphological operations:");
    let opened = binary_opening(
        &binary_image.view(),
        Some(&structure.view()),
        None,
        None,
        None,
    )?;
    let closed = binary_closing(
        &binary_image.view(),
        Some(&structure.view()),
        None,
        None,
        None,
    )?;
    println!("    Opening and closing operations completed");

    // 3. Grayscale morphology
    println!("  ‚Ä¢ Grayscale morphology:");
    let grey_eroded = grey_erosion(&image.view(), None, None, None, None, None)?;
    let grey_dilated = grey_dilation(&image.view(), None, None, None, None, None)?;
    println!("    Grayscale erosion and dilation completed");

    // 4. Distance transforms
    println!("  ‚Ä¢ Distance transforms:");
    let edt = distance_transform_edt(&binary_image.view(), None, None, None)?;
    println!("    Euclidean distance transform computed");

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_interpolation(image: &Array2<f64>) -> NdimageResult<()> {
    println!("üîÑ Interpolation & Transformations");

    // 1. Basic interpolation
    println!("  ‚Ä¢ Basic interpolation:");
    let zoomed = zoom(
        image,
        &[2.0, 1.5],
        InterpolationOrder::Linear,
        BoundaryMode::Reflect,
        None,
    )?;
    println!(
        "    Zoom: {}x{} -> {}x{}",
        image.nrows(),
        image.ncols(),
        zoomed.nrows(),
        zoomed.ncols()
    );

    // 2. Rotation
    println!("  ‚Ä¢ Rotation transformation:");
    let rotated = rotate(&image.view(), 45.0, None, None, None, None, None)?;
    println!("    45-degree rotation completed");

    // 3. Affine transformation
    println!("  ‚Ä¢ Affine transformation:");
    let transform_matrix = Array2::from_shape_vec(
        (2, 3),
        vec![
            1.2, 0.2, 10.0, // scale + shear + translation
            0.1, 1.1, 5.0,
        ],
    )?;
    let transformed = affine_transform(
        &image.view(),
        &transform_matrix.view(),
        InterpolationOrder::Linear,
        BoundaryMode::Constant,
        Some(0.0),
    )?;
    println!("    Affine transformation applied");

    // 4. Coordinate mapping
    println!("  ‚Ä¢ Coordinate mapping:");
    let coords = Array2::fromshape_fn((2, 100), |(axis, i)| {
        if axis == 0 {
            (i as f64 / 99.0) * (image.nrows() - 1) as f64
        } else {
            (i as f64 / 99.0) * (image.ncols() - 1) as f64
        }
    });
    let mapped_values = map_coordinates(
        &image.view(),
        &coords.view(),
        InterpolationOrder::Linear,
        BoundaryMode::Reflect,
        None,
    )?;
    println!(
        "    Coordinate mapping: {} values extracted",
        mapped_values.len()
    );

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_measurements(image: &Array2<f64>) -> NdimageResult<()> {
    println!("üìä Measurements & Analysis");

    // Create labeled image for region analysis
    let binary = image.mapv(|x| if x > 0.6 { 1u32 } else { 0u32 });
    let labeled = label(&binary.view(), None)?;

    // 1. Basic measurements
    println!("  ‚Ä¢ Basic measurements:");
    let com = center_of_mass(&image.view(), Some(&labeled.1.view()), None)?;
    println!("    Center of mass: {:?}", com);

    // 2. Statistical measurements
    println!("  ‚Ä¢ Statistical measurements:");
    let extrema_result = extrema(&image.view(), Some(&labeled.1.view()), None)?;
    println!("    Extrema found: {} regions", extrema_result.len());

    // 3. Moments analysis
    println!("  ‚Ä¢ Moments analysis:");
    let moments_result = moments(&image.view(), None, None)?;
    println!("    Moments computed for image");

    // 4. Region properties
    println!("  ‚Ä¢ Region properties:");
    let properties = region_properties(&labeled.1.view(), Some(&image.view()))?;
    println!("    Properties computed for {} regions", properties.len());
    for (i, prop) in properties.iter().take(3).enumerate() {
        println!(
            "      Region {}: area={:.1}, centroid=({:.1}, {:.1})",
            i, prop.area, prop.centroid[0], prop.centroid[1]
        );
    }

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_segmentation(image: &Array2<f64>) -> NdimageResult<()> {
    println!("‚úÇÔ∏è Segmentation");

    // 1. Thresholding
    println!("  ‚Ä¢ Thresholding methods:");
    let binary = threshold_binary(&image.view(), 0.5)?;
    let otsu = otsu_threshold(&image.view())?;
    let adaptive = adaptive_threshold(&image.view(), 15, AdaptiveMethod::Mean, 0.1)?;
    println!("    Binary, Otsu, and adaptive thresholding completed");

    // 2. Watershed segmentation
    println!("  ‚Ä¢ Watershed segmentation:");
    let markers = Array2::fromshape_fn(image.dim(), |(i, j)| {
        if i < 20 && j < 20 {
            1u32
        } else if i > image.nrows() - 20 && j > image.ncols() - 20 {
            2u32
        } else {
            0u32
        }
    });
    let watershed_result = watershed(&image.view(), &markers.view(), None, None)?;
    println!("    Watershed segmentation completed");

    #[cfg(feature = "simd")]
    {
        // 3. Advanced segmentation
        println!("  ‚Ä¢ Advanced segmentation methods:");

        // Graph cuts
        let graph_cuts_params = GraphCutsParams::default();
        let gc_result = graph_cuts(&image.view(), &markers.view(), graph_cuts_params)?;
        println!("    Graph cuts segmentation completed");

        // Chan-Vese
        let initial_contour = create_circle_contour((image.nrows() / 2, image.ncols() / 2), 30.0);
        let cv_params = ChanVeseParams::default();
        let cv_result = chan_vese(&image.view(), &initial_contour, cv_params)?;
        println!("    Chan-Vese segmentation completed");
    }

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_domain_specific(image: &Array2<f64>) -> NdimageResult<()> {
    println!("üè• Domain-Specific Functions");

    // 1. Medical imaging
    println!("  ‚Ä¢ Medical imaging functions:");
    let vesselness = medical::frangi_vesselness(&image.view(), None)?;
    println!("    Frangi vesselness filter applied");

    let enhanced_bone = medical::enhance_bone_structure(&image.view(), 1.0, 2.0)?;
    println!("    Bone structure enhancement completed");

    // 2. Satellite/remote sensing
    println!("  ‚Ä¢ Satellite/remote sensing:");
    let fake_nir = image + &Array2::ones(image.dim()) * 0.3; // Simulate NIR band
    let ndvi = satellite::compute_ndvi(&fake_nir.view(), &image.view())?;
    println!("    NDVI computation completed");

    let water_mask = satellite::detect_water_bodies(&image.view(), 0.3)?;
    println!("    Water body detection completed");

    // 3. Microscopy
    println!("  ‚Ä¢ Microscopy functions:");
    let cell_params = microscopy::CellSegmentationParams::default();
    let cells = microscopy::segment_cells(&image.view(), cell_params)?;
    println!("    Cell segmentation: {} cells detected", cells.len());

    Ok(())
}

#[cfg(feature = "simd")]
#[allow(dead_code)]
fn demonstrate_advanced_simd(image: &Array2<f64>) -> NdimageResult<()> {
    println!("‚ö° Advanced SIMD Extensions");

    // 1. Wavelet pyramid
    println!("  ‚Ä¢ Advanced-SIMD wavelet pyramid:");
    let pyramid = advanced_simd_wavelet_pyramid(image.view(), 3, WaveletType::Daubechies4)?;
    println!(
        "    Wavelet pyramid: {} levels generated",
        pyramid.levels.len()
    );

    // 2. Local Binary Patterns
    println!("  ‚Ä¢ Advanced-SIMD multi-scale LBP:");
    let lbp = advanced_simd_multi_scale_lbp(image.view(), &[1, 2, 3], &[8, 16, 24])?;
    println!("    Multi-scale LBP texture analysis completed");

    // 3. Advanced edge detection
    println!("  ‚Ä¢ Advanced-SIMD advanced edge detection:");
    let advanced_edges = advanced_simd_advanced_edge_detection(image.view(), 1.0, 0.1, 0.3)?;
    println!("    Advanced edge detection with multi-directional gradients completed");

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_backends(image: &Array2<f64>) -> NdimageResult<()> {
    println!("üñ•Ô∏è Backend & Performance Optimization");

    // 1. Backend selection
    println!("  ‚Ä¢ Backend configuration:");
    let backend = BackendBuilder::new()
        .backend(Backend::Cpu)
        .gpu_threshold(10000)
        .allow_fallback(true)
        .build()?;
    println!("    Backend configured with automatic GPU fallback");

    // 2. Auto backend selection
    println!("  ‚Ä¢ Automatic backend selection:");
    let auto_backend = auto_backend(&[image.nrows(), image.ncols()])?;
    println!("    Auto-selected backend: {:?}", auto_backend);

    #[cfg(feature = "cuda")]
    {
        println!("  ‚Ä¢ GPU acceleration available");
        // GPU-specific operations would go here
    }

    #[cfg(not(feature = "cuda"))]
    {
        println!("  ‚Ä¢ GPU acceleration not available (compile with --features cuda)");
    }

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_streaming() -> NdimageResult<()> {
    println!("üåä Streaming for Large Datasets");

    // Create a temporary large file simulation
    println!("  ‚Ä¢ Streaming configuration:");
    let config = StreamConfig {
        chunk_size: (512, 512),
        overlap: (32, 32),
        num_workers: 4,
        buffer_size: 1024 * 1024 * 100, // 100MB buffer
    };
    println!(
        "    Stream config: {}x{} chunks, {} workers",
        config.chunk_size.0, config.chunk_size.1, config.num_workers
    );

    // Create streaming processor
    println!("  ‚Ä¢ Streaming Gaussian filter setup:");
    let streaming_filter = StreamingGaussianFilter::new([2.0, 2.0]);
    println!("    Streaming Gaussian filter configured");

    println!("  ‚Ä¢ For real file processing, use:");
    println!("    stream_process_file(input_path, output_path, operation, config)");

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_memory_management(image: &Array2<f64>) -> NdimageResult<()> {
    println!("üß† Memory Management");

    use scirs2_ndimage::memory_management::*;

    // 1. Memory estimation
    println!("  ‚Ä¢ Memory usage estimation:");
    let memory_needed = estimate_memory_usage(&[image.nrows(), image.ncols()], 8)?; // 8 bytes per f64
    println!(
        "    Estimated memory for processing: {:.2} MB",
        memory_needed as f64 / 1_000_000.0
    );

    // 2. Memory configuration
    println!("  ‚Ä¢ Memory configuration:");
    let memory_config = MemoryConfig {
        max_memory_gb: 4.0,
        chunk_size_mb: 100.0,
        enable_memory_mapping: true,
        buffer_pool_size: 10,
    };
    println!(
        "    Memory limit: {:.1} GB, chunk size: {:.1} MB",
        memory_config.max_memory_gb, memory_config.chunk_size_mb
    );

    // 3. Buffer pool
    println!("  ‚Ä¢ Buffer pool management:");
    let buffer_pool = BufferPool::new(5, 1024 * 1024)?; // 5 buffers of 1MB each
    println!("    Buffer pool created with 5 buffers");

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_visualization(image: &Array2<f64>) -> NdimageResult<()> {
    println!("üìä Visualization");

    // 1. Colormaps
    println!("  ‚Ä¢ Colormap creation:");
    let colormap = create_colormap(ColorMap::Viridis, 256)?;
    println!("    Viridis colormap created with 256 colors");

    // 2. Statistical plots
    println!("  ‚Ä¢ Statistical visualization:");
    let plot_config = PlotConfig::default();
    let histogram_data = plot_histogram(&image.view(), 50, plot_config.clone())?;
    println!("    Histogram data generated for 50 bins");

    // 3. Report generation
    println!("  ‚Ä¢ Report generation:");
    let report_config = ReportConfig {
        format: ReportFormat::Html,
        include_statistics: true,
        include_plots: true,
        output_path: "analysis_report.html".into(),
    };
    println!("    Report configuration created for HTML output");

    Ok(())
}

#[allow(dead_code)]
fn demonstrate_best_practices() -> NdimageResult<()> {
    println!("üí° Best Practices & Optimization Tips");

    println!("  1. Performance Tips:");
    println!("     ‚Ä¢ Use SIMD features: compile with --features simd");
    println!("     ‚Ä¢ Enable parallel processing: --features parallel");
    println!("     ‚Ä¢ Choose appropriate data types (f32 vs f64)");
    println!("     ‚Ä¢ Use in-place operations when possible");

    println!("  2. Memory Optimization:");
    println!("     ‚Ä¢ Use streaming for large datasets (> 1GB)");
    println!("     ‚Ä¢ Configure appropriate chunk sizes");
    println!("     ‚Ä¢ Enable memory mapping for file processing");
    println!("     ‚Ä¢ Use buffer pools for repeated operations");

    println!("  3. Error Handling:");
    println!("     ‚Ä¢ Always handle NdimageResult errors");
    println!("     ‚Ä¢ Check input dimensions and data types");
    println!("     ‚Ä¢ Validate parameters before processing");

    println!("  4. API Selection:");
    println!("     ‚Ä¢ Use SciPy-compatible API for migration");
    println!("     ‚Ä¢ Use native Rust API for new code");
    println!("     ‚Ä¢ Combine with other scirs2 modules as needed");

    println!("  5. Backend Selection:");
    println!("     ‚Ä¢ Use auto backend selection for adaptive performance");
    println!("     ‚Ä¢ Configure GPU thresholds based on your hardware");
    println!("     ‚Ä¢ Enable fallback mechanisms for robustness");

    Ok(())
}

#[cfg(not(feature = "simd"))]
#[allow(dead_code)]
fn demonstrate_advanced_simd(image: &Array2<f64>) -> NdimageResult<()> {
    println!("‚ö° Advanced SIMD Extensions");
    println!("  Note: SIMD features not available (compile with --features simd)");
    Ok(())
}
