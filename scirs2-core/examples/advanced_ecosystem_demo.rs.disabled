//! Ultrathink Ecosystem Integration Demo
//!
//! This comprehensive demo showcases the full power of the SciRS2 ultrathink ecosystem,
//! demonstrating seamless integration across all modules for advanced scientific computing.
//!
//! # Features Demonstrated
//!
//! - Cross-module communication and coordination
//! - Intelligent resource management and optimization
//! - Adaptive performance tuning across the ecosystem
//! - Real-time monitoring and fault tolerance
//! - AI-driven workflow optimization
//! - Quantum-enhanced computation pipelines

// TODO: Ecosystem bridge module is not yet implemented
// use scirs2_core::ecosystem_bridge::{
//     EcosystemContext, InterModuleMessage, MessageType, ModulePerformanceMetrics,
//     ModuleResourceUsage, Priority, ProcessingContext, ProcessingMetrics, QualityRequirements,
//     TimingConstraints, UltrathinkEcosystemCoordinator, UltrathinkInput, UltrathinkModule,
//     UltrathinkOutput,
// };
use scirs2_core::error::{CoreError, CoreResult, ErrorContext};
use std::collections::HashMap;
use std::time::{Duration, Instant};

/// Demo implementation of a neural ultrathink module
#[derive(Debug)]
struct MockNeuralUltrathinkModule {
    name: String,
    version: String,
    initialized: bool,
    performance_metrics: ModulePerformanceMetrics,
    operation_count: u64,
}

impl MockNeuralUltrathinkModule {
    fn new() -> Self {
        Self {
            name: "neural-advanced".to_string(),
            version: "0.1.0-beta.1".to_string(),
            initialized: false,
            performance_metrics: ModulePerformanceMetrics {
                avg_processing_time: Duration::from_millis(50),
                ops_per_second: 1000.0,
                success_rate: 0.98,
                quality_score: 0.95,
                efficiency_score: 0.92,
            },
            operation_count: 0,
        }
    }
}

impl UltrathinkModule for MockNeuralUltrathinkModule {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn capabilities(&self) -> Vec<String> {
        vec![
            "neural_adaptive_processing".to_string(),
            "intelligent_resource_management".to_string(),
            "adaptive_learning".to_string(),
            "mixed_precision_training".to_string(),
        ]
    }

    fn initialize_advanced(&mut self) -> CoreResult<()> {
        println!("üß† Initializing Neural Ultrathink Module...");
        println!("   - Loading neural architectures");
        println!("   - Calibrating adaptive parameters");
        println!("   - Enabling mixed precision");
        self.initialized = true;
        Ok(())
    }

    fn process_advanced(&mut self, input: UltrathinkInput) -> CoreResult<UltrathinkOutput> {
        if !self.initialized {
            return Err(CoreError::InvalidInput(ErrorContext::new(
                "Module not initialized",
            )));
        }

        let start_time = Instant::now();
        self.operation_count += 1;

        // Simulate neural processing with adaptive optimization
        let processing_complexity = input.data.len() as f64 / 1000.0;
        let adaptive_delay = Duration::from_millis((processing_complexity * 10.0) as u64);
        std::thread::sleep(adaptive_delay);

        // Simulate neural transformation
        let mut output_data = input.data.clone();
        for byte in output_data.iter_mut() {
            *byte = byte.wrapping_add(42); // Neural transformation
        }

        let processing_time = start_time.elapsed();

        println!("üß† Neural processing completed:");
        println!("   - Input size: {} bytes", input.data.len());
        println!(
            "   - Processing time: {:.2} ms",
            processing_time.as_millis()
        );
        println!("   - Neural enhancement applied");

        Ok(UltrathinkOutput {
            data: output_data,
            metrics: ProcessingMetrics {
                processing_time,
                memory_used: input.data.len() * 2,
                cpu_cycles: 1000000,
                gpu_time: Some(Duration::from_millis(5)),
            },
            quality_score: 0.95,
            confidence: 0.92,
        })
    }

    fn get_performance_metrics(&self) -> ModulePerformanceMetrics {
        self.performance_metrics.clone()
    }

    fn get_resource_usage(&self) -> ModuleResourceUsage {
        ModuleResourceUsage {
            memory_mb: 512.0 + (self.operation_count as f64 * 0.1),
            cpu_percentage: 45.0,
            gpu_percentage: Some(25.0),
            network_bandwidth: 10.0,
        }
    }

    fn optimize_for_ecosystem(&mut self, context: &EcosystemContext) -> CoreResult<()> {
        println!("üîß Neural module optimizing for ecosystem:");
        println!("   - Adjusting batch size based on available memory");
        println!("   - Tuning neural network depth");
        println!(
            "   - Optimizing GPU utilization: {:.1}%",
            context.available_resources.gpu_usage.unwrap_or(0.0) * 100.0
        );

        // Simulate optimization
        if context.available_resources.memory_usage < 0.5 {
            println!("   - Enabling aggressive memory preloading");
        }

        Ok(())
    }

    fn handle_communication(
        &mut self,
        message: InterModuleMessage,
    ) -> CoreResult<InterModuleMessage> {
        println!("üì® Neural module received message from {}", message.from);

        let response = InterModuleMessage {
            from: self.name.clone(),
            to: message.from,
            message_type: MessageType::StatusUpdate,
            payload: format!(
                "Neural processing complete. Operations: {}",
                self.operation_count
            )
            .into_bytes(),
            timestamp: Instant::now(),
        };

        Ok(response)
    }

    fn shutdown(&mut self) -> CoreResult<()> {
        println!("üß† Shutting down Neural Ultrathink Module...");
        println!("   - Saving neural weights");
        println!("   - Finalizing adaptive parameters");
        self.initialized = false;
        Ok(())
    }
}

/// Demo implementation of a clustering advanced module
#[derive(Debug)]
struct MockClusteringUltrathinkModule {
    name: String,
    version: String,
    initialized: bool,
    operation_count: u64,
}

impl MockClusteringUltrathinkModule {
    fn new() -> Self {
        Self {
            name: "clustering-ultrathink".to_string(),
            version: "0.1.0-beta.1".to_string(),
            initialized: false,
            operation_count: 0,
        }
    }
}

impl UltrathinkModule for MockClusteringUltrathinkModule {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn capabilities(&self) -> Vec<String> {
        vec![
            "quantum_neuromorphic_clustering".to_string(),
            "ai_algorithm_selection".to_string(),
            "meta_learning_optimization".to_string(),
            "continual_adaptation".to_string(),
        ]
    }

    fn initialize_advanced(&mut self) -> CoreResult<()> {
        println!("üéØ Initializing Clustering Ultrathink Module...");
        println!("   - Loading quantum-neuromorphic algorithms");
        println!("   - Calibrating meta-learning parameters");
        println!("   - Initializing adaptive clustering engine");
        self.initialized = true;
        Ok(())
    }

    fn process_advanced(&mut self, input: UltrathinkInput) -> CoreResult<UltrathinkOutput> {
        if !self.initialized {
            return Err(CoreError::InvalidInput(ErrorContext::new(
                "Module not initialized",
            )));
        }

        let start_time = Instant::now();
        self.operation_count += 1;

        // Simulate quantum-neuromorphic clustering
        let cluster_complexity = (input.data.len() as f64).sqrt();
        let processing_delay = Duration::from_millis((cluster_complexity * 2.0) as u64);
        std::thread::sleep(processing_delay);

        // Simulate clustering transformation
        let mut output_data = Vec::new();
        for chunk in input.data.chunks(4) {
            let cluster_id = chunk[0] % 8; // Simulate cluster assignment
            output_data.push(cluster_id);
        }

        let processing_time = start_time.elapsed();

        println!("üéØ Quantum-neuromorphic clustering completed:");
        println!("   - Input size: {} bytes", input.data.len());
        println!("   - Clusters identified: {}", output_data.len());
        println!(
            "   - Processing time: {:.2} ms",
            processing_time.as_millis()
        );
        println!("   - Quantum advantage: 2.5x");

        Ok(UltrathinkOutput {
            data: output_data,
            metrics: ProcessingMetrics {
                processing_time,
                memory_used: input.data.len() / 2,
                cpu_cycles: 750000,
                gpu_time: Some(Duration::from_millis(3)),
            },
            quality_score: 0.93,
            confidence: 0.89,
        })
    }

    fn get_performance_metrics(&self) -> ModulePerformanceMetrics {
        ModulePerformanceMetrics {
            avg_processing_time: Duration::from_millis(30),
            ops_per_second: 1500.0,
            success_rate: 0.96,
            quality_score: 0.93,
            efficiency_score: 0.88,
        }
    }

    fn get_resource_usage(&self) -> ModuleResourceUsage {
        ModuleResourceUsage {
            memory_mb: 256.0 + (self.operation_count as f64 * 0.05),
            cpu_percentage: 35.0,
            gpu_percentage: Some(15.0),
            network_bandwidth: 5.0,
        }
    }

    fn optimize_for_ecosystem(&mut self, context: &EcosystemContext) -> CoreResult<()> {
        println!("üîß Clustering module optimizing for ecosystem:");
        println!("   - Adjusting cluster granularity");
        println!("   - Optimizing quantum coherence time");
        println!(
            "   - CPU utilization: {:.1}%",
            context.available_resources.cpu_usage * 100.0
        );

        Ok(())
    }

    fn handle_communication(
        &mut self,
        message: InterModuleMessage,
    ) -> CoreResult<InterModuleMessage> {
        println!(
            "üì® Clustering module received message from {}",
            message.from
        );

        let response = InterModuleMessage {
            from: self.name.clone(),
            to: message.from,
            message_type: MessageType::StatusUpdate,
            payload: format!(
                "Clustering analysis complete. Operations: {}",
                self.operation_count
            )
            .into_bytes(),
            timestamp: Instant::now(),
        };

        Ok(response)
    }

    fn shutdown(&mut self) -> CoreResult<()> {
        println!("üéØ Shutting down Clustering Ultrathink Module...");
        println!("   - Saving quantum states");
        println!("   - Persisting meta-learning models");
        self.initialized = false;
        Ok(())
    }
}

/// Demo implementation of an I/O advanced module
#[derive(Debug)]
struct MockIoUltrathinkModule {
    name: String,
    version: String,
    initialized: bool,
    operation_count: u64,
}

impl MockIoUltrathinkModule {
    fn new() -> Self {
        Self {
            name: "io-ultrathink".to_string(),
            version: "0.1.0-beta.1".to_string(),
            initialized: false,
            operation_count: 0,
        }
    }
}

impl UltrathinkModule for MockIoUltrathinkModule {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn capabilities(&self) -> Vec<String> {
        vec![
            "adaptive_compression".to_string(),
            "quantum_parallel_processing".to_string(),
            "neural_adaptive_io".to_string(),
            "intelligent_buffering".to_string(),
        ]
    }

    fn initialize_advanced(&mut self) -> CoreResult<()> {
        println!("üíæ Initializing I/O Ultrathink Module...");
        println!("   - Configuring adaptive compression algorithms");
        println!("   - Initializing quantum parallel processors");
        println!("   - Calibrating neural I/O controllers");
        self.initialized = true;
        Ok(())
    }

    fn process_advanced(&mut self, input: UltrathinkInput) -> CoreResult<UltrathinkOutput> {
        if !self.initialized {
            return Err(CoreError::InvalidInput(ErrorContext::new(
                "Module not initialized",
            )));
        }

        let start_time = Instant::now();
        self.operation_count += 1;

        // Simulate adaptive I/O processing
        let io_complexity = input.data.len() as f64 / 2000.0;
        let processing_delay = Duration::from_millis((io_complexity * 5.0) as u64);
        std::thread::sleep(processing_delay);

        // Simulate adaptive compression
        let compression_ratio = 0.6; // 60% compression
        let compressed_size = (input.data.len() as f64 * compression_ratio) as usize;
        let mut output_data = Vec::with_capacity(compressed_size);

        // Simple compression simulation
        for chunk in input.data.chunks(2) {
            let compressed_byte = chunk.iter().fold(0u8, |acc, &x| acc.wrapping_add(x));
            output_data.push(compressed_byte);
        }

        let processing_time = start_time.elapsed();

        println!("üíæ Adaptive I/O processing completed:");
        println!("   - Input size: {} bytes", input.data.len());
        println!("   - Compressed size: {} bytes", output_data.len());
        println!("   - Compression ratio: {:.1}%", compression_ratio * 100.0);
        println!(
            "   - Processing time: {:.2} ms",
            processing_time.as_millis()
        );

        Ok(UltrathinkOutput {
            data: output_data,
            metrics: ProcessingMetrics {
                processing_time,
                memory_used: input.data.len(),
                cpu_cycles: 500000,
                gpu_time: None,
            },
            quality_score: 0.91,
            confidence: 0.87,
        })
    }

    fn get_performance_metrics(&self) -> ModulePerformanceMetrics {
        ModulePerformanceMetrics {
            avg_processing_time: Duration::from_millis(20),
            ops_per_second: 2000.0,
            success_rate: 0.99,
            quality_score: 0.91,
            efficiency_score: 0.94,
        }
    }

    fn get_resource_usage(&self) -> ModuleResourceUsage {
        ModuleResourceUsage {
            memory_mb: 128.0 + (self.operation_count as f64 * 0.02),
            cpu_percentage: 25.0,
            gpu_percentage: None,
            network_bandwidth: 50.0,
        }
    }

    fn optimize_for_ecosystem(&mut self, context: &EcosystemContext) -> CoreResult<()> {
        println!("üîß I/O module optimizing for ecosystem:");
        println!("   - Adjusting buffer sizes");
        println!("   - Optimizing compression algorithms");
        println!(
            "   - Network usage: {:.1}%",
            context.available_resources.network_usage * 100.0
        );

        Ok(())
    }

    fn handle_communication(
        &mut self,
        message: InterModuleMessage,
    ) -> CoreResult<InterModuleMessage> {
        println!("üì® I/O module received message from {}", message.from);

        let response = InterModuleMessage {
            from: self.name.clone(),
            to: message.from,
            message_type: MessageType::DataTransfer,
            payload: "I/O processing complete. Efficiency: 94%"
                .to_string()
                .into_bytes(),
            timestamp: Instant::now(),
        };

        Ok(response)
    }

    fn shutdown(&mut self) -> CoreResult<()> {
        println!("üíæ Shutting down I/O Ultrathink Module...");
        println!("   - Flushing adaptive buffers");
        println!("   - Saving compression models");
        self.initialized = false;
        Ok(())
    }
}

/// Comprehensive ecosystem workflow demo
struct UltrathinkWorkflowDemo {
    coordinator: UltrathinkEcosystemCoordinator,
}

impl UltrathinkWorkflowDemo {
    fn new() -> Self {
        Self {
            coordinator: UltrathinkEcosystemCoordinator::new(),
        }
    }

    /// Run the complete advanced ecosystem demo
    fn run_demo(&mut self) -> CoreResult<()> {
        println!("üöÄ SciRS2 Ultrathink Ecosystem Integration Demo");
        println!("================================================\n");

        // Phase 1: Module Registration
        self.register_modules()?;

        // Phase 2: Initialize Ecosystem
        self.initialize_ecosystem()?;

        // Phase 3: Demonstrate Processing Pipeline
        self.demonstrate_processing_pipeline()?;

        // Phase 4: Show Cross-Module Communication
        self.demonstrate_cross_module_communication()?;

        // Phase 5: Performance Optimization
        self.demonstrate_performance_optimization()?;

        // Phase 6: Real-time Monitoring
        self.demonstrate_monitoring()?;

        // Phase 7: Ecosystem Analytics
        self.show_ecosystem_analytics()?;

        // Phase 8: Graceful Shutdown
        self.graceful_shutdown()?;

        Ok(())
    }

    fn register_modules(&mut self) -> CoreResult<()> {
        println!("üìã Phase 1: Registering Ultrathink Modules");
        println!("==========================================");

        // Register neural module
        let neural_module = Box::new(MockNeuralUltrathinkModule::new());
        self.coordinator.register_module(neural_module)?;

        // Register clustering module
        let clustering_module = Box::new(MockClusteringUltrathinkModule::new());
        self.coordinator.register_module(clustering_module)?;

        // Register I/O module
        let io_module = Box::new(MockIoUltrathinkModule::new());
        self.coordinator.register_module(io_module)?;

        let status = self.coordinator.get_status()?;
        println!(
            "‚úÖ Registered {} modules successfully",
            status.active_modules
        );
        println!("   - Ecosystem health: {:?}", status.health);

        Ok(())
    }

    fn initialize_ecosystem(&mut self) -> CoreResult<()> {
        println!("\n‚ö° Phase 2: Initializing Ultrathink Ecosystem");
        println!("===========================================");

        // Start monitoring
        self.coordinator.start_monitoring()?;

        // Initialize all modules (would be done automatically in real implementation)
        println!("üîÑ Initializing all registered modules...");

        println!("‚úÖ Ecosystem initialization complete");

        Ok(())
    }

    fn demonstrate_processing_pipeline(&mut self) -> CoreResult<()> {
        println!("\nüîÑ Phase 3: Demonstrating Processing Pipeline");
        println!("============================================");

        // Create test data
        let test_data = generate_test_data(1024);

        let input = UltrathinkInput {
            data: test_data,
            parameters: {
                let mut params = HashMap::new();
                params.insert("quality_threshold".to_string(), 0.9);
                params.insert("performance_target".to_string(), 1000.0);
                params
            },
            context: ProcessingContext {
                operation_type: "scientific_computation".to_string(),
                expected_format: "compressed_output".to_string(),
                quality_requirements: QualityRequirements {
                    min_accuracy: 0.95,
                    max_error: 0.01,
                    precision: 6,
                },
                timing_constraints: TimingConstraints {
                    max_processing_time: Duration::from_secs(5),
                    deadline: Some(Instant::now() + Duration::from_secs(10)),
                    real_time: false,
                },
            },
            priority: Priority::High,
        };

        println!("üéØ Processing data through advanced ecosystem...");
        let start_time = Instant::now();

        let output = self.coordinator.process_ecosystem(input)?;

        let total_time = start_time.elapsed();

        println!("\nüìä Processing Results:");
        println!(
            "   - Total processing time: {:.2} ms",
            total_time.as_millis()
        );
        println!("   - Output size: {} bytes", output.data.len());
        println!("   - Quality score: {:.3}", output.quality_score);
        println!("   - Confidence: {:.3}", output.confidence);
        println!("   - Memory used: {} bytes", output.metrics.memory_used);

        Ok(())
    }

    fn demonstrate_cross_module_communication(&mut self) -> CoreResult<()> {
        println!("\nüì° Phase 4: Cross-Module Communication");
        println!("=====================================");

        println!("üîÑ Simulating inter-module data exchange...");
        println!("   - Neural ‚Üí Clustering: Feature vectors");
        println!("   - Clustering ‚Üí I/O: Cluster results");
        println!("   - I/O ‚Üí Neural: Compressed feedback");

        // In a real implementation, this would trigger actual communication
        std::thread::sleep(Duration::from_millis(100));

        println!("‚úÖ Cross-module communication successful");
        println!("   - Message latency: < 1ms average");
        println!("   - Communication efficiency: 98.5%");

        Ok(())
    }

    fn demonstrate_performance_optimization(&mut self) -> CoreResult<()> {
        println!("\nüîß Phase 5: Performance Optimization");
        println!("===================================");

        println!("üéØ Running ecosystem-wide optimization...");
        self.coordinator.optimize_ecosystem()?;

        println!("üìà Optimization Results:");
        println!("   - Cross-module coordination improved");
        println!("   - Resource allocation optimized");
        println!("   - Load balancing activated");
        println!("   - Overall efficiency: +15%");

        Ok(())
    }

    fn demonstrate_monitoring(&mut self) -> CoreResult<()> {
        println!("\nüìä Phase 6: Real-time Monitoring");
        println!("===============================");

        println!("üîç Monitoring ecosystem performance...");

        // Simulate some processing load
        for i in 1..=5 {
            let test_data = generate_test_data(256 * i);
            let input = UltrathinkInput {
                data: test_data,
                parameters: HashMap::new(),
                context: ProcessingContext {
                    operation_type: "monitoring_test".to_string(),
                    expected_format: "raw".to_string(),
                    quality_requirements: QualityRequirements {
                        min_accuracy: 0.8,
                        max_error: 0.1,
                        precision: 3,
                    },
                    timing_constraints: TimingConstraints {
                        max_processing_time: Duration::from_millis(500),
                        deadline: None,
                        real_time: true,
                    },
                },
                priority: Priority::Normal,
            };

            let _ = self.coordinator.process_ecosystem(input)?;
            println!("   Batch {i}/5 processed");
        }

        let status = self.coordinator.get_status()?;
        println!("\nüìà Current Status:");
        println!("   - Total operations: {}", status.total_operations);
        println!(
            "   - Average response time: {:.2} ms",
            status.avg_response_time
        );
        println!(
            "   - CPU usage: {:.1}%",
            status.resource_utilization.cpu_usage * 100.0
        );
        println!(
            "   - Memory usage: {:.1}%",
            status.resource_utilization.memory_usage * 100.0
        );

        Ok(())
    }

    fn show_ecosystem_analytics(&mut self) -> CoreResult<()> {
        println!("\nüìä Phase 7: Ecosystem Analytics");
        println!("==============================");

        let report = self.coordinator.get_performance_report()?;

        println!("üîç Performance Analytics:");
        println!(
            "   - System throughput: {:.1} ops/sec",
            report.system_metrics.total_throughput
        );
        println!(
            "   - Average latency: {:.2} ms",
            report.system_metrics.avg_latency.as_millis()
        );
        println!(
            "   - Error rate: {:.3}%",
            report.system_metrics.error_rate * 100.0
        );
        println!(
            "   - Resource efficiency: {:.1}%",
            report.system_metrics.resource_efficiency * 100.0
        );
        println!(
            "   - Quality score: {:.3}",
            report.system_metrics.quality_score
        );

        println!("\nüí° Recommendations:");
        for recommendation in &report.recommendations {
            println!("   - {recommendation}");
        }

        Ok(())
    }

    fn graceful_shutdown(&mut self) -> CoreResult<()> {
        println!("\nüîÑ Phase 8: Graceful Shutdown");
        println!("============================");

        self.coordinator.shutdown()?;

        println!("‚úÖ Ultrathink ecosystem demo completed successfully!");
        println!("\nüéâ Summary:");
        println!("   - All modules integrated seamlessly");
        println!("   - Cross-module communication verified");
        println!("   - Performance optimization demonstrated");
        println!("   - Real-time monitoring operational");
        println!("   - Graceful shutdown completed");

        Ok(())
    }
}

/// Generate test data for demonstrations
#[allow(dead_code)]
fn generate_test_data(size: usize) -> Vec<u8> {
    (0..size)
        .map(|i| {
            // Generate pseudo-scientific data with patterns
            let base = (i as f64 * 0.1).sin() * 127.0 + 128.0;
            let noise = ((i * 17 + 42) % 256) as f64 * 0.1;
            (base + noise) as u8
        })
        .collect()
}

#[allow(dead_code)]
fn main() -> CoreResult<()> {
    println!("üåü SciRS2 Ultrathink Ecosystem Integration Demo");
    println!("===============================================");
    println!("‚ö†Ô∏è  Note: This demo is currently disabled as the ecosystem_bridge");
    println!("   module is not yet implemented. Please check back in a future release!");

    // TODO: Uncomment when ecosystem_bridge module is implemented
    // let mut demo = UltrathinkWorkflowDemo::new();
    // demo.run_demo()?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mock_neural_module() {
        let mut module = MockNeuralUltrathinkModule::new();
        assert_eq!(module.name(), "neural-advanced");
        assert!(!module.capabilities().is_empty());

        module.initialize_ultrathink().unwrap();
        assert!(module.initialized);
    }

    #[test]
    fn test_mock_clustering_module() {
        let mut module = MockClusteringUltrathinkModule::new();
        assert_eq!(module.name(), "clustering-advanced");
        assert!(module
            .capabilities()
            .contains(&"quantum_neuromorphic_clustering".to_string()));
    }

    #[test]
    fn test_mock_io_module() {
        let mut module = MockIoUltrathinkModule::new();
        assert_eq!(module.name(), "io-advanced");
        assert!(module
            .capabilities()
            .contains(&"adaptive_compression".to_string()));
    }

    #[test]
    fn test_ecosystem_coordinator() {
        let coordinator = UltrathinkEcosystemCoordinator::new();
        let status = coordinator.get_status().unwrap();
        assert_eq!(status.active_modules, 0);
    }

    #[test]
    fn test_generate_test_data() {
        let data = generate_test_data(100);
        assert_eq!(data.len(), 100);
        assert!(data.iter().any(|&x| x != 0)); // Should have varied data
    }
}
