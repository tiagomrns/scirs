//! Integration tests for advanced spatial modules
//!
//! This module provides comprehensive integration testing between different
//! advanced spatial computing paradigms: quantum-inspired algorithms,
//! neuromorphic computing, and hybrid approaches.

use ndarray::array;
use scirs2_spatial::{
    // Core spatial algorithms
    KDTree, distance::euclidean, distance::pdist,
    
    // Advanced modules
    quantum_inspired::{QuantumClusterer, QuantumNearestNeighbor, QuantumSpatialOptimizer},
    neuromorphic::{SpikingNeuralClusterer, NeuromorphicProcessor},
    quantum_classical_hybrid::{HybridSpatialOptimizer, HybridClusterer},
    
    // Memory and performance
    memory_pool::global_distance_pool,
    gpu_accel::{is_gpu_acceleration_available, report_gpu_status},
};
use approx::assert_relative_eq;
use std::time::Instant;

/// Test data generator for integration tests
fn generate_test_data(n_points: usize, n_dims: usize, n_clusters: usize) -> ndarray::Array2<f64> {
    let mut data = ndarray::Array2::zeros((n_points, n_dims));
    let cluster_size = n_points / n_clusters;
    
    for cluster in 0..n_clusters {
        let center: Vec<f64> = (0..n_dims).map(|_| cluster as f64 * 10.0).collect();
        
        for i in 0..cluster_size.min(n_points - cluster * cluster_size) {
            let point_idx = cluster * cluster_size + i;
            for dim in 0..n_dims {
                // Add some noise around cluster centers
                let noise = (i as f64 / cluster_size as f64 - 0.5) * 2.0;
                data[[point_idx, dim]] = center[dim] + noise;
            }
        }
    }
    
    data
}

/// Integration test: Quantum-enhanced spatial indexing
#[tokio::test]
async fn test_quantum_enhanced_spatial_indexing() -> Result<(), Box<dyn std::error::Error>> {
    let points = generate_test_data(100, 2, 3);
    
    // Build classical KDTree
    let classical_kdtree = KDTree::new(&points)?;
    
    // Create quantum nearest neighbor searcher
    let quantum_nn = QuantumNearestNeighbor::new(&points.view())?;
    
    let query_point = array![5.0, 5.0];
    let k = 5;
    
    // Test classical approach
    let start = Instant::now();
    let (classical_indices, classical_distances) = classical_kdtree.query(&query_point.as_slice().unwrap(), k)?;
    let classical_time = start.elapsed();
    
    // Test quantum approach
    let start = Instant::now();
    let (quantum_indices, quantum_distances) = quantum_nn.query_quantum(&query_point.view(), k)?;
    let quantum_time = start.elapsed();
    
    // Validate results are reasonable (quantum should find similar results)
    assert_eq!(classical_indices.len(), k);
    assert_eq!(quantum_indices.len(), k);
    assert_eq!(classical_distances.len(), k);
    assert_eq!(quantum_distances.len(), k);
    
    // Check that distances are non-negative and ordered
    for i in 1..k {
        assert!(classical_distances[i] >= classical_distances[i-1]);
        assert!(quantum_distances[i] >= quantum_distances[i-1]);
    }
    
    println!("Quantum-Enhanced Spatial Indexing Integration Test:");
    println!("  Classical k-NN time: {:?}", classical_time);
    println!("  Quantum k-NN time: {:?}", quantum_time);
    println!("  Classical distances: {:?}", classical_distances);
    println!("  Quantum distances: {:?}", quantum_distances);
    
    Ok(())
}

/// Integration test: Neuromorphic-guided clustering
#[tokio::test]
async fn test_neuromorphic_guided_clustering() -> Result<(), Box<dyn std::error::Error>> {
    let points = generate_test_data(50, 2, 3);
    let n_clusters = 3;
    
    // Classical distance matrix for comparison
    let classical_distances = pdist(&points, euclidean);
    
    // Neuromorphic clustering
    let mut spiking_clusterer = SpikingNeuralClusterer::new(n_clusters);
    let (neuromorphic_result, _spike_events) = spiking_clusterer.fit(&points.view())?;
    
    // Validate clustering results
    assert_eq!(neuromorphic_result.len(), points.nrows());
    
    // Check that we have the expected number of clusters
    let mut unique_labels = neuromorphic_result.to_vec();
    unique_labels.sort_unstable();
    unique_labels.dedup();
    assert!(unique_labels.len() <= n_clusters);
    
    // Validate cluster centers are reasonable
    assert_eq!(neuromorphic_result.centers.nrows(), n_clusters);
    assert_eq!(neuromorphic_result.centers.ncols(), points.ncols());
    
    // Check silhouette score is reasonable (should be positive for good clustering)
    assert!(neuromorphic_result.silhouette_score > -1.0);
    assert!(neuromorphic_result.silhouette_score <= 1.0);
    
    println!("Neuromorphic-Guided Clustering Integration Test:");
    println!("  Points clustered: {}", points.nrows());
    println!("  Clusters found: {}", unique_labels.len());
    println!("  Silhouette score: {:.3}", neuromorphic_result.silhouette_score);
    println!("  Inertia: {:.3}", neuromorphic_result.inertia);
    
    Ok(())
}

/// Integration test: Hybrid quantum-classical optimization
#[tokio::test]
async fn test_hybrid_quantum_classical_optimization() -> Result<(), Box<dyn std::error::Error>> {
    let points = generate_test_data(30, 2, 2);
    
    // Test hybrid spatial optimizer
    let mut hybrid_optimizer = HybridSpatialOptimizer::new()
        .with_quantum_depth(3)
        .with_classical_refinement(true)
        .with_adaptive_switching(0.7);
    
    let start = Instant::now();
    let optimization_result = hybrid_optimizer.optimize_spatial_problem(&points.view()).await?;
    let optimization_time = start.elapsed();
    
    // Validate optimization results
    assert!(optimization_result.iterations > 0);
    assert!(optimization_result.final_cost >= 0.0);
    assert!(optimization_result.quantum_advantage_ratio >= 0.0);
    
    // Test hybrid clustering
    let mut hybrid_clusterer = HybridClusterer::new(2)
        .with_quantum_depth(3)
        .with_classical_refinement(true);
    
    let start = Instant::now();
    let clustering_result = hybrid_clusterer.cluster(&points.view()).await?;
    let clustering_time = start.elapsed();
    
    // Validate clustering results
    assert_eq!(clustering_result.labels.len(), points.nrows());
    assert_eq!(clustering_result.centers.nrows(), 2);
    assert!(clustering_result.quantum_advantage_ratio >= 0.0);
    
    println!("Hybrid Quantum-Classical Optimization Integration Test:");
    println!("  Optimization time: {:?}", optimization_time);
    println!("  Optimization iterations: {}", optimization_result.iterations);
    println!("  Final cost: {:.3}", optimization_result.final_cost);
    println!("  Quantum advantage: {:.3}x", optimization_result.quantum_advantage_ratio);
    println!("  Clustering time: {:?}", clustering_time);
    println!("  Clustering quantum advantage: {:.3}x", clustering_result.quantum_advantage_ratio);
    
    Ok(())
}

/// Integration test: Memory pool integration with advanced algorithms
#[tokio::test]
async fn test_memory_pool_integration() -> Result<(), Box<dyn std::error::Error>> {
    let points = generate_test_data(1000, 3, 5);
    
    // Get global memory pool
    let pool = global_distance_pool();
    let initial_stats = pool.statistics();
    
    // Perform quantum clustering that should use memory pool
    let mut quantum_clusterer = QuantumClusterer::new(5);
    let quantum_result = quantum_clusterer.cluster(&points.view()).await?;
    
    // Perform neuromorphic processing that should use memory pool
    let mut spiking_clusterer = SpikingNeuralClusterer::new(5);
    let (neuromorphic_result, _spike_events) = spiking_clusterer.fit(&points.view())?;
    
    let final_stats = pool.statistics();
    
    // Validate that memory pool was utilized
    assert!(final_stats.total_allocations >= initial_stats.total_allocations);
    
    // Validate algorithm results
    assert_eq!(quantum_result.labels.len(), points.nrows());
    assert_eq!(neuromorphic_result.len(), points.nrows());
    
    println!("Memory Pool Integration Test:");
    println!("  Initial pool allocations: {}", initial_stats.total_allocations);
    println!("  Final pool allocations: {}", final_stats.total_allocations);
    println!("  Pool hit rate: {:.1}%", final_stats.hit_rate());
    println!("  Memory efficiency gain: {:.1}%", 
             (final_stats.hit_rate() - initial_stats.hit_rate()).max(0.0));
    
    Ok(())
}

/// Integration test: GPU acceleration with advanced algorithms
#[tokio::test]
async fn test_gpu_acceleration_integration() -> Result<(), Box<dyn std::error::Error>> {
    // Check GPU availability
    report_gpu_status();
    
    if !is_gpu_acceleration_available() {
        println!("GPU acceleration not available, skipping GPU integration test");
        return Ok(());
    }
    
    let points = generate_test_data(500, 4, 3);
    
    // Test quantum clustering with potential GPU acceleration
    let mut quantum_clusterer = QuantumClusterer::new(3, 64, 100, 0.01)?;
    
    let start = Instant::now();
    let gpu_result = quantum_clusterer.cluster(&points.view()).await?;
    let gpu_time = start.elapsed();
    
    // Validate results
    assert_eq!(gpu_result.labels.len(), points.nrows());
    assert_eq!(gpu_result.centers.nrows(), 3);
    
    println!("GPU Acceleration Integration Test:");
    println!("  GPU-accelerated clustering time: {:?}", gpu_time);
    println!("  Points processed: {}", points.nrows());
    println!("  Dimensions: {}", points.ncols());
    println!("  Silhouette score: {:.3}", gpu_result.silhouette_score);
    
    Ok(())
}

/// Performance comparison integration test
#[tokio::test]
async fn test_performance_comparison_integration() -> Result<(), Box<dyn std::error::Error>> {
    let test_sizes = vec![50, 100, 200];
    let n_clusters = 3;
    
    println!("Performance Comparison Integration Test:");
    println!("----------------------------------------");
    
    for size in test_sizes {
        let points = generate_test_data(size, 2, n_clusters);
        
        // Classical approach (using KDTree for nearest neighbor)
        let start = Instant::now();
        let kdtree = KDTree::new(&points)?;
        let (_, _) = kdtree.query(&[5.0, 5.0], 5)?;
        let classical_time = start.elapsed();
        
        // Quantum approach
        let start = Instant::now();
        let quantum_nn = QuantumNearestNeighbor::new(32, 10, 0.01, 0.7)?;
        let (_, _) = quantum_nn.search(&points.view(), &array![5.0, 5.0].view(), 5).await?;
        let quantum_time = start.elapsed();
        
        // Neuromorphic approach
        let start = Instant::now();
        let mut spiking_clusterer = SpikingNeuralClusterer::new(n_clusters);
        let _ = spiking_clusterer.cluster(&points.view()).await?;
        let neuromorphic_time = start.elapsed();
        
        println!("  Size {}: Classical={:?}, Quantum={:?}, Neuromorphic={:?}", 
                 size, classical_time, quantum_time, neuromorphic_time);
    }
    
    Ok(())
}

/// Error handling and fallback integration test
#[tokio::test]
async fn test_error_handling_integration() -> Result<(), Box<dyn std::error::Error>> {
    // Test with invalid data
    let empty_points = ndarray::Array2::<f64>::zeros((0, 2));
    
    // Test quantum clustering with empty data
    let mut quantum_clusterer = QuantumClusterer::new(3, 32, 50, 0.01)?;
    let quantum_result = quantum_clusterer.cluster(&empty_points.view()).await;
    assert!(quantum_result.is_err(), "Quantum clustering should fail with empty data");
    
    // Test neuromorphic clustering with empty data
    let mut spiking_clusterer = SpikingNeuralClusterer::new(3);
    let neuromorphic_result = spiking_clusterer.cluster(&empty_points.view()).await;
    assert!(neuromorphic_result.is_err(), "Neuromorphic clustering should fail with empty data");
    
    // Test with single point (edge case)
    let single_point = array![[1.0, 2.0]];
    
    let mut quantum_clusterer = QuantumClusterer::new(1);
    let quantum_result = quantum_clusterer.cluster(&single_point.view()).await;
    // Should either succeed with 1 cluster or fail gracefully
    match quantum_result {
        Ok(result) => {
            assert_eq!(result.labels.len(), 1);
            assert_eq!(result.centers.nrows(), 1);
        },
        Err(_) => {
            // Graceful failure is also acceptable for edge cases
        }
    }
    
    println!("Error Handling Integration Test:");
    println!("  Empty data handling: ✓ (proper error propagation)");
    println!("  Edge case handling: ✓ (graceful degradation)");
    
    Ok(())
}

/// Scalability integration test
#[tokio::test]
async fn test_scalability_integration() -> Result<(), Box<dyn std::error::Error>> {
    let sizes = vec![10, 50, 100];
    
    println!("Scalability Integration Test:");
    println!("----------------------------");
    
    for size in sizes {
        let points = generate_test_data(size, 2, 3);
        
        // Test quantum scaling
        let start = Instant::now();
        let mut quantum_clusterer = QuantumClusterer::new(3);
        let quantum_result = quantum_clusterer.cluster(&points.view()).await?;
        let quantum_time = start.elapsed();
        
        // Test neuromorphic scaling
        let start = Instant::now();
        let mut spiking_clusterer = SpikingNeuralClusterer::new(3);
        let (neuromorphic_result, _spike_events) = spiking_clusterer.fit(&points.view())?;
        let neuromorphic_time = start.elapsed();
        
        // Validate results scale properly
        assert_eq!(quantum_result.labels.len(), size);
        assert_eq!(neuromorphic_result.labels.len(), size);
        
        println!("  Size {}: Quantum={:?}, Neuromorphic={:?}", 
                 size, quantum_time, neuromorphic_time);
    }
    
    Ok(())
}

/// Cross-module API consistency integration test
#[tokio::test]
async fn test_api_consistency_integration() -> Result<(), Box<dyn std::error::Error>> {
    let points = generate_test_data(50, 2, 3);
    let n_clusters = 3;
    
    // Test that all clustering algorithms return consistent result structures
    
    // Quantum clustering
    let mut quantum_clusterer = QuantumClusterer::new(n_clusters);
    let quantum_result = quantum_clusterer.cluster(&points.view()).await?;
    
    // Neuromorphic clustering
    let mut spiking_clusterer = SpikingNeuralClusterer::new(n_clusters);
    let (neuromorphic_result, _spike_events) = spiking_clusterer.fit(&points.view())?;
    
    // Hybrid clustering
    let mut hybrid_clusterer = HybridClusterer::new(n_clusters);
    let hybrid_result = hybrid_clusterer.cluster(&points.view()).await?;
    
    // Validate API consistency
    assert_eq!(quantum_result.labels.len(), points.nrows());
    assert_eq!(neuromorphic_result.len(), points.nrows());
    assert_eq!(hybrid_result.labels.len(), points.nrows());
    
    assert_eq!(quantum_result.centers.nrows(), n_clusters);
    assert_eq!(neuromorphic_result.centers.nrows(), n_clusters);
    assert_eq!(hybrid_result.centers.nrows(), n_clusters);
    
    assert_eq!(quantum_result.centers.ncols(), points.ncols());
    assert_eq!(neuromorphic_result.centers.ncols(), points.ncols());
    assert_eq!(hybrid_result.centers.ncols(), points.ncols());
    
    // All should have silhouette scores
    assert!(quantum_result.silhouette_score >= -1.0 && quantum_result.silhouette_score <= 1.0);
    assert!(neuromorphic_result.silhouette_score >= -1.0 && neuromorphic_result.silhouette_score <= 1.0);
    // Note: hybrid_result uses different metrics, but should still be reasonable
    
    println!("API Consistency Integration Test:");
    println!("  Quantum clustering: ✓ (consistent API)");
    println!("  Neuromorphic clustering: ✓ (consistent API)");
    println!("  Hybrid clustering: ✓ (consistent API)");
    println!("  All algorithms return compatible result structures");
    
    Ok(())
}