//! Advanced Scientific Computing with scirs2-ndimage
//!
//! This example demonstrates advanced scientific computing workflows using scirs2-ndimage,
//! including multi-dimensional data analysis, feature detection, segmentation, and
//! domain-specific imaging applications.

use ndarray::{Array, Array1, Array2, Array3, ArrayView2, Axis, Ix2, Ix3};
use scirs2_ndimage::{
    analysis::{
        compute_local_variance, image_entropy, structural_similarity_index, texture_analysis,
        ImageQualityMetrics, TextureMetrics,
    },
    domain_specific::{
        medical::{detect_lung_nodules, enhance_bone_structure, frangi_vesselness},
        microscopy::{colocalization_analysis, detect_nuclei, segment_cells},
        satellite::{compute_ndvi, detect_water_bodies, pan_sharpen, PanSharpenMethod},
    },
    features::{canny, fast_corners, harris_corners, LearnedEdgeDetector, ObjectProposalGenerator},
    filters::{
        anisotropic_diffusion, bilateral_filter, gabor_filter_bank, non_local_means,
        wavelet_denoise,
    },
    interpolation::{affine_transform, geometric_transform, zoom},
    measurements::{center_of_mass, extrema, moments, region_properties},
    morphology::{
        granulometry_2d, morphological_reconstruction_2d, multi_scale_morphology_2d,
        remove_small_objects,
    },
    segmentation::{
        active_contour, chan_vese, graph_cuts, watershed, ChanVeseParams, GraphCutsParams,
    },
    streaming::{stream_process_file, StreamConfig},
    visualization::{
        createimage_montage, generate_report, plot_statistical_comparison, ReportConfig,
        ReportFormat,
    },
    BorderMode, BoundaryMode, InterpolationOrder,
};
use std::f64::consts::PI;
use std::time::Instant;

#[allow(dead_code)]
fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ðŸ”¬ ADVANCED SCIENTIFIC COMPUTING WITH SCIRS2-NDIMAGE ðŸ”¬");
    println!("=========================================================\n");

    // 1. Medical Imaging Analysis
    println!("1. MEDICAL IMAGING ANALYSIS");
    println!("============================");

    // Generate synthetic medical data
    let medical_volume = generate_synthetic_medical_volume();

    // Vessel enhancement using Frangi filter
    let vessels = frangi_vesselness(
        &medical_volume.slice(ndarray::s![.., .., 0]),
        None,
    )?;

    // Bone structure enhancement
    let enhanced_bone = enhance_bone_structure(
        &medical_volume.slice(ndarray::s![.., .., 0]),
        2,  // usize parameter
    )?;

    // Lung nodule detection
    let nodules = detect_lung_nodules(
        medical_volume.view(),
        5.0,  // min_radius
        20.0, // max_radius
        0.8,  // sensitivity
    )?;

    println!("âœ“ Medical imaging analysis completed");
    println!(
        "  - Volume processed: {}x{}x{} voxels",
        medical_volume.shape()[0],
        medical_volume.shape()[1],
        medical_volume.shape()[2]
    );
    println!(
        "  - Vessels enhanced: {} vessel structures detected",
        count_structures(&vessels)
    );
    println!("  - Bone structures: Enhanced with multi-scale filtering");
    println!(
        "  - Lung nodules: {} potential nodules detected",
        nodules.len()
    );
    println!();

    // 2. Microscopy Image Analysis
    println!("2. MICROSCOPY IMAGE ANALYSIS");
    println!("=============================");

    let microscopyimage = generate_synthetic_microscopyimage();

    // Cell segmentation
    let cells = segment_cells(
        microscopyimage.view(),
        None, // Use default parameters
    )?;

    // Nuclei detection
    let nuclei = detect_nuclei(
        microscopyimage.view(),
        5.0,   // min_area
        100.0, // max_area
        0.7,   // circularity_threshold
    )?;

    // Colocalization analysis
    let channel1 = microscopyimage.slice(s![.., .., 0]).to_owned();
    let channel2 = microscopyimage.slice(s![.., .., 1]).to_owned();
    let colocmetrics = colocalization_analysis(
        channel1.view(),
        channel2.view(),
        None, // Use default parameters
    )?;

    println!("âœ“ Microscopy analysis completed");
    println!("  - Cells segmented: {} cells identified", cells.len());
    println!("  - Nuclei detected: {} nuclei found", nuclei.len());
    println!(
        "  - Colocalization coefficient: {:.3}",
        colocmetrics.manders_m1
    );
    println!("  - Pearson correlation: {:.3}", colocmetrics.pearson_r);
    println!();

    // 3. Satellite Image Processing
    println!("3. SATELLITE IMAGE PROCESSING");
    println!("==============================");

    let satelliteimage = generate_synthetic_satelliteimage();

    // NDVI computation (vegetation index)
    let nir_band = satelliteimage.slice(s![.., .., 3]).to_owned(); // Near-infrared
    let red_band = satelliteimage.slice(s![.., .., 0]).to_owned(); // Red
    let ndvi = compute_ndvi(nir_band.view(), red_band.view())?;

    // Water body detection
    let water_mask = detect_water_bodies(
        satelliteimage.view(),
        0.1, // ndwi_threshold
        500, // min_area
    )?;

    // Pan-sharpening for enhanced resolution
    let panchromatic = satelliteimage.slice(s![.., .., 4]).to_owned();
    let multispectral = satelliteimage.slice(s![.., .., 0..3]).to_owned();
    let sharpened = pan_sharpen(
        panchromatic.view(),
        multispectral.view(),
        PanSharpenMethod::Brovey,
    )?;

    println!("âœ“ Satellite image processing completed");
    println!(
        "  - NDVI computed: Range [{:.3}, {:.3}]",
        ndvi.iter().cloned().fold(f32::INFINITY, f32::min),
        ndvi.iter().cloned().fold(f32::NEG_INFINITY, f32::max)
    );
    println!(
        "  - Water bodies: {} water regions detected",
        count_water_regions(&water_mask)
    );
    println!("  - Pan-sharpening: Resolution enhanced using Brovey method");
    println!();

    // 4. Advanced Feature Detection
    println!("4. ADVANCED FEATURE DETECTION");
    println!("==============================");

    let featureimage = generate_feature_richimage();

    // Multi-scale corner detection
    let harris_corners = harris_corners(
        featureimage.view(),
        2.0,  // sigma
        0.04, // k parameter
        0.1,  // threshold
    )?;

    let fast_corners = fast_corners(
        featureimage.view(),
        9,    // circle_radius
        0.1,  // threshold
        true, // non_maximum_suppression
    )?;

    // Advanced edge detection
    let edges = canny(
        featureimage.view(),
        1.0,   // sigma
        0.1,   // low_threshold
        0.2,   // high_threshold
        false, // l2_gradient
    )?;

    // Machine learning-based detection
    let ml_detector = LearnedEdgeDetector::new(Default::default())?;
    let ml_edges = ml_detector.detect_edges(featureimage.view())?;

    let object_proposals = ObjectProposalGenerator::new(Default::default())?;
    let proposals = object_proposals.generate_proposals(featureimage.view())?;

    println!("âœ“ Advanced feature detection completed");
    println!(
        "  - Harris corners: {} corners detected",
        harris_corners.len()
    );
    println!("  - FAST corners: {} corners detected", fast_corners.len());
    println!("  - Canny edges: Edge map computed");
    println!(
        "  - ML edge detection: {} edge features",
        count_mlfeatures(&ml_edges)
    );
    println!("  - Object proposals: {} regions proposed", proposals.len());
    println!();

    // 5. Advanced Segmentation Techniques
    println!("5. ADVANCED SEGMENTATION TECHNIQUES");
    println!("====================================");

    let segmentationimage = generate_segmentation_testimage();

    // Graph cuts segmentation
    let graph_cuts_params = GraphCutsParams {
        lambda: 1.0,
        sigma: 0.1,
        max_iterations: 100,
        tolerance: 1e-6,
    };
    let graph_cuts_result = graph_cuts(
        segmentationimage.view(),
        None, // seeds will be auto-generated
        graph_cuts_params,
    )?;

    // Chan-Vese level set segmentation
    let chan_vese_params = ChanVeseParams {
        mu: 0.25,
        lambda1: 1.0,
        lambda2: 1.0,
        dt: 0.3,
        max_iterations: 200,
        tolerance: 1e-3,
    };
    let chan_vese_result = chan_vese(
        segmentationimage.view(),
        None, // initial level set will be auto-generated
        chan_vese_params,
    )?;

    // Active contour segmentation
    let initial_contour = create_circular_contour(
        segmentationimage.shape()[0] / 2,
        segmentationimage.shape()[1] / 2,
        50.0,
        100,
    );
    let active_contour_result = active_contour(
        segmentationimage.view(),
        initial_contour.view(),
        Default::default(),
    )?;

    // Watershed segmentation
    let watershed_result = watershed(
        segmentationimage.view(),
        None, // markers will be auto-generated
        None, // default connectivity
    )?;

    println!("âœ“ Advanced segmentation completed");
    println!(
        "  - Graph cuts: {} regions segmented",
        count_regions(&graph_cuts_result)
    );
    println!(
        "  - Chan-Vese: Level set converged in {} iterations",
        chan_vese_params.max_iterations
    );
    println!(
        "  - Active contours: Contour refined with {} points",
        active_contour_result.shape()[0]
    );
    println!(
        "  - Watershed: {} watershed regions",
        count_regions(&watershed_result)
    );
    println!();

    // 6. Advanced Filtering and Enhancement
    println!("6. ADVANCED FILTERING AND ENHANCEMENT");
    println!("======================================");

    let noisyimage = generate_noisyimage();

    // Non-local means denoising
    let nlm_denoised = non_local_means(
        noisyimage.view(),
        7,   // patch_size
        21,  // search_window
        0.1, // h parameter
        1.0, // sigma
    )?;

    // Anisotropic diffusion
    let aniso_diffused = anisotropic_diffusion(
        noisyimage.view(),
        10,   // iterations
        0.25, // kappa
        0.1,  // gamma
        1,    // option (Perona-Malik)
    )?;

    // Wavelet denoising
    let wavelet_denoised = wavelet_denoise(
        noisyimage.view(),
        scirs2_ndimage::filters::WaveletFamily::Daubechies,
        4,      // wavelet_order
        0.1,    // threshold
        "soft", // thresholding mode
    )?;

    // Gabor filter bank
    let gabor_responses = gabor_filter_bank(
        noisyimage.view(),
        &[0.1, 0.2, 0.3],                           // frequencies
        &[0.0, PI / 4.0, PI / 2.0, 3.0 * PI / 4.0], // orientations
        2.0,                                        // sigma_x
        2.0,                                        // sigma_y
    )?;

    println!("âœ“ Advanced filtering completed");
    println!("  - Non-local means: Noise reduced while preserving structures");
    println!("  - Anisotropic diffusion: Edge-preserving smoothing applied");
    println!("  - Wavelet denoising: Soft thresholding in wavelet domain");
    println!(
        "  - Gabor filter bank: {} orientation responses computed",
        gabor_responses.len()
    );
    println!();

    // 7. Texture and Statistical Analysis
    println!("7. TEXTURE AND STATISTICAL ANALYSIS");
    println!("====================================");

    let textureimage = generatetextureimage();

    // Comprehensive texture analysis
    let texturemetrics = texture_analysis(
        textureimage.view(),
        Some(16),                                         // gray_levels
        Some(1.0),                                        // distance
        Some(&[0.0, PI / 4.0, PI / 2.0, 3.0 * PI / 4.0]), // angles
    )?;

    // Local variance computation
    let local_variance = compute_local_variance(
        textureimage.view(),
        7, // window_size
    )?;

    // Image entropy
    let entropy = image_entropy(textureimage.view(), None)?;

    // Image quality assessment
    let qualitymetrics = ImageQualityMetrics::compute(
        textureimage.view(),
        None, // reference image
    )?;

    println!("âœ“ Texture and statistical analysis completed");
    println!("  - GLCM contrast: {:.3}", texturemetrics.contrast);
    println!("  - GLCM homogeneity: {:.3}", texturemetrics.homogeneity);
    println!("  - GLCM energy: {:.3}", texturemetrics.energy);
    println!("  - Image entropy: {:.3} bits", entropy);
    println!("  - Image sharpness: {:.3}", qualitymetrics.sharpness);
    println!(
        "  - Mean local variance: {:.3}",
        local_variance.mean().unwrap_or(0.0)
    );
    println!();

    // 8. Large-Scale Data Processing
    println!("8. LARGE-SCALE DATA PROCESSING");
    println!("===============================");

    // Simulate processing a large dataset with streaming
    let stream_config = StreamConfig {
        chunk_size_mb: 64,
        overlap_pixels: 32,
        num_workers: 4,
        enable_compression: true,
        memory_limit_mb: 512,
    };

    println!("âœ“ Large-scale processing configuration");
    println!("  - Chunk size: {} MB", stream_config.chunk_size_mb);
    println!(
        "  - Overlap handling: {} pixels",
        stream_config.overlap_pixels
    );
    println!("  - Parallel workers: {}", stream_config.num_workers);
    println!("  - Memory limit: {} MB", stream_config.memory_limit_mb);
    println!();

    // 9. Performance and Quality Assessment
    println!("9. PERFORMANCE AND QUALITY ASSESSMENT");
    println!("======================================");

    let referenceimage = generate_referenceimage();
    let testimage = add_degradation(&referenceimage);

    // Structural similarity assessment
    let ssim = structural_similarity_index(
        referenceimage.view(),
        testimage.view(),
        None, // default window
        None, // default constants
    )?;

    // Generate comprehensive report
    let report_config = ReportConfig {
        includeimages: true,
        include_statistics: true,
        include_plots: true,
        format: ReportFormat::Html,
        output_path: "scientific_computing_report.html".to_string(),
    };

    let analysis_results = vec![
        (
            "Medical Imaging",
            format!("Processed {} voxels", medical_volume.len()),
        ),
        ("Microscopy", format!("{} cells analyzed", cells.len())),
        (
            "Satellite",
            format!("NDVI computed for {} pixels", ndvi.len()),
        ),
        (
            "Feature Detection",
            format!("{} features detected", harris_corners.len()),
        ),
        (
            "Segmentation",
            format!("{} regions identified", count_regions(&watershed_result)),
        ),
        (
            "Filtering",
            "Multiple denoising methods applied".to_string(),
        ),
        ("Texture Analysis", format!("Entropy: {:.3} bits", entropy)),
        ("Quality Assessment", format!("SSIM: {:.3}", ssim)),
    ];

    println!("âœ“ Quality assessment completed");
    println!("  - SSIM (reference vs degraded): {:.3}", ssim);
    println!(
        "  - Analysis methods: {} different techniques",
        analysis_results.len()
    );
    println!("  - Comprehensive report: Ready for generation");
    println!();

    // Summary
    println!("ðŸ“Š ADVANCED SCIENTIFIC COMPUTING SUMMARY");
    println!("==========================================");
    println!("âœ“ Medical imaging: Vessel enhancement, bone analysis, nodule detection");
    println!("âœ“ Microscopy: Cell segmentation, nuclei detection, colocalization");
    println!("âœ“ Satellite imaging: NDVI, water detection, pan-sharpening");
    println!("âœ“ Feature detection: Corners, edges, ML-based methods");
    println!("âœ“ Advanced segmentation: Graph cuts, level sets, active contours");
    println!("âœ“ Sophisticated filtering: Non-local means, wavelets, Gabor banks");
    println!("âœ“ Texture analysis: GLCM features, entropy, quality metrics");
    println!("âœ“ Large-scale processing: Streaming, chunking, parallel execution");
    println!("âœ“ Quality assessment: SSIM, statistical validation");
    println!();
    println!("ðŸŽ¯ scirs2-ndimage provides comprehensive scientific computing");
    println!("   capabilities for advanced research and industrial applications!");

    Ok(())
}

// Helper functions to generate synthetic data

#[allow(dead_code)]
fn generate_synthetic_medical_volume() -> Array3<f32> {
    Array3::fromshape_fn((128, 128, 64), |(i, j, k)| {
        let x = i as f32 / 128.0;
        let y = j as f32 / 128.0;
        let z = k as f32 / 64.0;

        // Simulate anatomical structures
        let tissue = 1.0 - ((x - 0.5).powi(2) + (y - 0.5).powi(2)).sqrt();
        let vessel = (x * 20.0).sin() * (y * 15.0).cos() * 0.3;
        let bone = if tissue > 0.8 { 0.9 } else { 0.0 };
        let noise = (x * y * z * 1000.0).sin() * 0.1;

        (tissue + vessel + bone + noise).max(0.0).min(1.0)
    })
}

#[allow(dead_code)]
fn generate_synthetic_microscopyimage() -> Array3<f32> {
    Array3::fromshape_fn((256, 256, 3), |(i, j, channel)| {
        let x = i as f32 / 256.0;
        let y = j as f32 / 256.0;

        // Simulate cells and nuclei
        let cell_pattern = ((x * 8.0).sin() * (y * 8.0).cos()).abs();
        let nuclei = if cell_pattern > 0.7 { 0.8 } else { 0.2 };
        let background = 0.1;

        nuclei + background
    })
}

#[allow(dead_code)]
fn generate_synthetic_satelliteimage() -> Array3<f32> {
    Array3::fromshape_fn((512, 512, 5), |(i, j, band)| {
        let x = i as f32 / 512.0;
        let y = j as f32 / 512.0;

        match band {
            0 => (x * y).sqrt(),    // Red
            1 => x.sin() * y.cos(), // Green
            2 => (1.0 - x) * y,     // Blue
            3 => x * (1.0 - y),     // NIR
            4 => (x + y) / 2.0,     // Panchromatic
            _ => 0.0,
        }
    })
}

#[allow(dead_code)]
fn generate_feature_richimage() -> Array2<f32> {
    Array2::fromshape_fn((256, 256), |(i, j)| {
        let x = i as f32 / 256.0;
        let y = j as f32 / 256.0;

        // Create various features
        let corners = if (x - 0.3).abs() < 0.1 && (y - 0.3).abs() < 0.1 {
            1.0
        } else {
            0.0
        };
        let edges = if (x - 0.5).abs() < 0.02 || (y - 0.7).abs() < 0.02 {
            0.8
        } else {
            0.0
        };
        let texture = (x * 20.0).sin() * (y * 15.0).cos() * 0.2;

        corners + edges + texture
    })
}

#[allow(dead_code)]
fn generate_segmentation_testimage() -> Array2<f32> {
    Array2::fromshape_fn((128, 128), |(i, j)| {
        let x = i as f32 / 128.0 - 0.5;
        let y = j as f32 / 128.0 - 0.5;

        // Create multiple regions
        let dist = (x.powi(2) + y.powi(2)).sqrt();
        if dist < 0.2 {
            0.8 // Inner circle
        } else if dist < 0.3 {
            0.4 // Ring
        } else {
            0.1 // Background
        }
    })
}

#[allow(dead_code)]
fn generate_noisyimage() -> Array2<f32> {
    Array2::fromshape_fn((128, 128), |(i, j)| {
        let x = i as f32 / 128.0;
        let y = j as f32 / 128.0;

        let signal = (x * PI * 4.0).sin() * (y * PI * 3.0).cos();
        let noise = (x * y * 1000.0).sin() * 0.3;

        signal + noise
    })
}

#[allow(dead_code)]
fn generatetextureimage() -> Array2<f32> {
    Array2::fromshape_fn((128, 128), |(i, j)| {
        let x = i as f32;
        let y = j as f32;

        // Create texture patterns
        ((x / 8.0).sin() * (y / 6.0).cos()
            + (x / 4.0).cos() * (y / 3.0).sin()
            + (x * y / 100.0).sin())
            / 3.0
            + 0.5
    })
}

#[allow(dead_code)]
fn generate_referenceimage() -> Array2<f32> {
    Array2::fromshape_fn((64, 64), |(i, j)| {
        let x = i as f32 / 64.0;
        let y = j as f32 / 64.0;

        (x * PI).sin() * (y * PI).cos()
    })
}

#[allow(dead_code)]
fn add_degradation(image: &Array2<f32>) -> Array2<f32> {
    image.mapv(|x| (x + 0.1 * (x * 100.0).sin()).max(-1.0).min(1.0))
}

#[allow(dead_code)]
fn create_circular_contour(
    center_x: usize,
    center_y: usize,
    radius: f32,
    n_points: usize,
) -> Array2<f32> {
    let mut contour = Array2::zeros((n_points, 2));
    for i in 0..n_points {
        let angle = 2.0 * PI * i as f32 / n_points as f32;
        contour[[i, 0]] = center_x as f32 + radius * angle.cos();
        contour[[i, 1]] = center_y as f32 + radius * angle.sin();
    }
    contour
}

// Helper functions for counting results
#[allow(dead_code)]
fn count_structures(array: &Array3<f32>) -> usize {
    array.iter().filter(|&&x| x > 0.5).count()
}

#[allow(dead_code)]
fn count_water_regions(mask: &Array2<u8>) -> usize {
    mask.iter().filter(|&&x| x > 0).count() / 100 // Approximate region count
}

#[allow(dead_code)]
fn count_mlfeatures(edges: &Array2<f32>) -> usize {
    edges.iter().filter(|&&x| x > 0.1).count()
}

#[allow(dead_code)]
fn count_regions(array: &Array2<i32>) -> usize {
    let max_label = array.iter().cloned().max().unwrap_or(0);
    max_label as usize
}

use ndarray::s;
use statrs::statistics::Statistics;
