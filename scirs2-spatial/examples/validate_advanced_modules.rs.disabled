//! Validation script for advanced spatial modules
//!
//! This script validates that all advanced modules are properly enabled
//! and functional by testing basic operations from each module.

use ndarray::{array, Array1};
use scirs2_spatial::{
    ai_driven_optimization::AIAlgorithmSelector,
    distance::euclidean,

    extreme_performance_optimization::ExtremeOptimizer,
    // GPU and memory optimizations
    gpu_accel::{is_gpu_acceleration_available, report_gpu_status},
    memory_pool::global_distance_pool,

    ml_optimization::NeuralSpatialOptimizer,
    neuromorphic::SpikingNeuralClusterer,
    quantum_classical_hybrid::{HybridClusterer, HybridSpatialOptimizer},

    // Advanced modules to validate
    quantum_inspired::{QuantumClusterer, QuantumNearestNeighbor},
    // Check if imports work
    tensor_cores::detect_tensor_core_capabilities,
    // Core spatial algorithms for comparison
    KDTree,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üî¨ SciRS2-Spatial Advanced Modules Validation");
    println!("============================================");

    // Generate test data
    let points = array![
        [0.0, 0.0],
        [1.0, 0.0],
        [0.0, 1.0],
        [1.0, 1.0],
        [2.0, 2.0],
        [3.0, 3.0],
        [4.0, 4.0],
        [5.0, 5.0],
    ];

    let mut all_passed = true;

    // Test 1: Core functionality (baseline)
    println!("\nüìä Testing Core Functionality...");
    match test_core_functionality(&points).await {
        Ok(_) => println!("‚úÖ Core functionality: PASSED"),
        Err(e) => {
            println!("‚ùå Core functionality: FAILED - {e}");
            all_passed = false;
        }
    }

    // Test 2: Quantum-inspired algorithms
    println!("\nüî¨ Testing Quantum-Inspired Algorithms...");
    match test_quantum_inspired(&points).await {
        Ok(_) => println!("‚úÖ Quantum-inspired: PASSED"),
        Err(e) => {
            println!("‚ùå Quantum-inspired: FAILED - {e}");
            all_passed = false;
        }
    }

    // Test 3: Neuromorphic computing
    println!("\nüß† Testing Neuromorphic Computing...");
    match test_neuromorphic(&points).await {
        Ok(_) => println!("‚úÖ Neuromorphic: PASSED"),
        Err(e) => {
            println!("‚ùå Neuromorphic: FAILED - {e}");
            all_passed = false;
        }
    }

    // Test 4: Hybrid algorithms
    println!("\nüîÑ Testing Hybrid Quantum-Classical...");
    match test_hybrid_algorithms(&points).await {
        Ok(_) => println!("‚úÖ Hybrid algorithms: PASSED"),
        Err(e) => {
            println!("‚ùå Hybrid algorithms: FAILED - {e}");
            all_passed = false;
        }
    }

    // Test 5: GPU acceleration
    println!("\nüñ•Ô∏è  Testing GPU Acceleration...");
    match test_gpu_acceleration().await {
        Ok(_) => println!("‚úÖ GPU acceleration: PASSED"),
        Err(e) => {
            println!("‚ö†Ô∏è  GPU acceleration: SKIPPED - {e}");
            // GPU tests are optional, don't fail validation
        }
    }

    // Test 6: Memory optimization
    println!("\nüíæ Testing Memory Optimization...");
    match test_memory_optimization().await {
        Ok(_) => println!("‚úÖ Memory optimization: PASSED"),
        Err(e) => {
            println!("‚ùå Memory optimization: FAILED - {e}");
            all_passed = false;
        }
    }

    // Test 7: Advanced optimization modules
    println!("\nüöÄ Testing Advanced Optimization Modules...");
    match test_advanced_optimization().await {
        Ok(_) => println!("‚úÖ Advanced optimization: PASSED"),
        Err(e) => {
            println!("‚ùå Advanced optimization: FAILED - {e}");
            all_passed = false;
        }
    }

    // Final validation summary
    println!("\nüèÅ Validation Summary");
    println!("===================");

    if all_passed {
        println!("üéâ ALL TESTS PASSED! Advanced modules are fully functional.");
        println!("   SciRS2-Spatial is ready for production use with:");
        println!("   ‚Ä¢ Quantum-inspired spatial algorithms");
        println!("   ‚Ä¢ Neuromorphic computing acceleration");
        println!("   ‚Ä¢ Hybrid quantum-classical optimization");
        println!("   ‚Ä¢ Advanced memory and GPU optimizations");
        println!("   ‚Ä¢ AI-driven algorithm selection");

        std::process::exit(0);
    } else {
        println!("‚ùå Some tests failed. Please check the output above.");
        println!("   Advanced modules may need additional configuration.");

        std::process::exit(1);
    }
}

async fn test_core_functionality(
    points: &ndarray::Array2<f64>,
) -> Result<(), Box<dyn std::error::Error>> {
    // Test basic KDTree functionality
    let kdtree = KDTree::new(points)?;
    let (indices, distances) = kdtree.query(&[2.5, 2.5], 3)?;

    if indices.len() != 3 || distances.len() != 3 {
        return Err("KDTree query returned wrong number of results".into());
    }

    // Test distance calculation
    let dist = euclidean(&[0.0, 0.0], &[1.0, 1.0]);
    let expected = (2.0f64).sqrt();
    if (dist - expected).abs() > 1e-10 {
        return Err("Distance calculation incorrect".into());
    }

    Ok(())
}

async fn test_quantum_inspired(
    points: &ndarray::Array2<f64>,
) -> Result<(), Box<dyn std::error::Error>> {
    // Test quantum clustering
    let mut quantum_clusterer = QuantumClusterer::new(2);
    let (centers, labels) = quantum_clusterer.fit(&points.view())?;

    if labels.len() != points.nrows() {
        return Err("Quantum clustering returned wrong number of labels".into());
    }

    if centers.nrows() != 2 {
        return Err("Quantum clustering returned wrong number of centers".into());
    }

    // Test quantum nearest neighbor
    let quantum_nn = QuantumNearestNeighbor::new(&points.view())?;
    let (indices, distances) = quantum_nn.query_quantum(&array![2.0, 2.0].view(), 3)?;

    if indices.len() != 3 || distances.len() != 3 {
        return Err("Quantum NN search returned wrong number of results".into());
    }

    Ok(())
}

async fn test_neuromorphic(
    points: &ndarray::Array2<f64>,
) -> Result<(), Box<dyn std::error::Error>> {
    // Test spiking neural clustering
    let mut spiking_clusterer = SpikingNeuralClusterer::new(2);
    let (labels_spike_events) = spiking_clusterer.fit(&points.view())?;

    if labels.len() != points.nrows() {
        return Err("Neuromorphic clustering returned wrong number of labels".into());
    }

    // Note: Neuromorphic clustering returns spike events and labels
    // Silhouette score calculation would need to be done separately

    Ok(())
}

async fn test_hybrid_algorithms(
    points: &ndarray::Array2<f64>,
) -> Result<(), Box<dyn std::error::Error>> {
    // Test hybrid spatial optimizer
    let mut hybrid_optimizer = HybridSpatialOptimizer::new()
        .with_quantum_classical_coupling(0.7)
        .with_adaptive_switching(true);

    // Create a simple spatial objective function for testing
    let objective_function = |params: &Array1<f64>| {
        // Simple quadratic function for testing
        params.iter().map(|&x| x * x).sum::<f64>()
    };

    let optimization_result = hybrid_optimizer
        .optimize_spatial_function(objective_function)
        .await?;

    if optimization_result.iterations == 0 {
        return Err("Hybrid optimizer reported zero iterations".into());
    }

    if optimization_result.optimal_value < 0.0 {
        return Err("Hybrid optimizer reported negative value".into());
    }

    // Test hybrid clustering
    let mut hybrid_clusterer = HybridClusterer::new(2)
        .with_quantum_exploration_ratio(0.7)
        .with_classical_refinement(true);

    let (_centers, labels_metrics) = hybrid_clusterer.fit(&points.view()).await?;

    if labels.len() != points.nrows() {
        return Err("Hybrid clustering returned wrong number of labels".into());
    }

    Ok(())
}

async fn test_gpu_acceleration() -> Result<(), Box<dyn std::error::Error>> {
    // Check GPU status
    report_gpu_status();

    if !is_gpu_acceleration_available() {
        return Err("GPU acceleration not available on this system".into());
    }

    // Test tensor core capabilities detection
    let tensor_caps = detect_tensor_core_capabilities()?;
    println!(
        "   Detected tensor core capabilities: {} types available",
        tensor_caps.tensor_core_types.len()
    );

    Ok(())
}

async fn test_memory_optimization() -> Result<(), Box<dyn std::error::Error>> {
    // Test memory pool
    let pool = global_distance_pool();
    let stats = pool.statistics();

    println!("   Memory pool statistics:");
    println!("     Total allocations: {}", stats.total_allocations());
    println!("     Hit rate: {:.1}%", stats.hit_rate());

    // Get a buffer to test the pool
    let buffer = pool.get_distance_buffer(100);

    if buffer.len() != 100 {
        return Err("Memory pool returned wrong buffer size".into());
    }

    Ok(())
}

async fn test_advanced_optimization() -> Result<(), Box<dyn std::error::Error>> {
    // Test extreme optimizer creation
    let _extreme_optimizer = ExtremeOptimizer::new()
        .with_numa_optimization(true)
        .with_cache_oblivious_algorithms(true)
        .with_lock_free_structures(true);

    // Test AI algorithm selector creation
    let _ai_selector = AIAlgorithmSelector::new()
        .with_meta_learning(true)
        .with_real_time_adaptation(true);

    // Test neural spatial optimizer creation
    let _neural_optimizer = NeuralSpatialOptimizer::new()
        .with_network_architecture(vec![64, 32, 16])
        .with_learning_rate(0.001);

    println!("   Successfully created all advanced optimization modules");

    Ok(())
}
